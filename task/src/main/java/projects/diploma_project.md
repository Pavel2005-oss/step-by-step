# Техническое задание: Проект социальной сети (Backend на Java)

## 1. Общее описание проекта
**Цель и краткое описание:**  Данный проект представляет собой **бэкенд для социальной сети**  – систему, позволяющую пользователям взаимодействовать друг с другом онлайн. Проект реализован без визуальной части (без пользовательского интерфейса), предоставляя функциональность через REST API. Пользовательский интерфейс (веб или мобильное приложение) сможет обращаться к этому API для выполнения операций.**Целевая аудитория:**  Целевая аудитория – широкая: активные интернет-пользователи, желающие общаться, делиться новостями и контентом с друзьями и подписчиками. Также система может использоваться разработчиками, которые будут создавать фронтенд-приложения (веб-сайты, мобильные приложения) для конечных пользователей социальной сети.**Основной функционал:**  Платформа предоставляет следующие ключевые возможности для пользователей:
- **Регистрация и авторизация пользователей:**  создание нового аккаунта, вход в систему с проверкой учетных данных, восстановление пароля (при необходимости).

- **Управление профилем:**  создание и редактирование профиля пользователя (имя, фото аватара – в пределах бэкенда хранится только ссылка или идентификатор изображения, и др. личная информация).

- **Социальные связи:**  поиск пользователей, отправка запросов в друзья, принятие/отклонение дружбы, просмотр списка друзей.

- **Публикация контента:**  создание текстовых постов (с возможностью прикрепления медиа – **в данном проекте фокус на бэкенде** , поэтому медиа может представляться ссылкой или хранилищем в будущем), редактирование и удаление своих постов.

- **Лента новостей:**  формирование и выдача ленты постов от друзей/подписок пользователя в порядке времени создания (с пагинацией).

- **Взаимодействие с постами:**  возможность ставить "лайки" постам, оставлять комментарии.

- **Уведомления:**  (опционально) рассылка уведомлений пользователям о важных событиях – например, новый запрос в друзья, новый лайк или комментарий к посту.

- **Администрирование:**  (опционально) роль администратора для модерации контента и управления пользователями.
  Все функции предоставляются через **RESTful API** . Проект реализован на языке Java с использованием фреймворка Spring Boot и сопутствующих технологий, с хранением данных в реляционной базе PostgreSQL. Визуальная часть (интерфейс) не входит в рамки данного ТЗ, однако API спроектирован так, чтобы его было удобно использовать в веб или мобильных клиентах.
## 2. Область применения (Scope) и бизнес-требования
**Задачи, решаемые проектом:**  Проект предназначен для решения задач онлайн-взаимодействия и коммуникации. С его помощью пользователи смогут поддерживать социальные связи через интернет: находить знакомых, обмениваться сообщениями (в форме постов и комментариев), выражать реакцию на записи друг друга. Платформа централизует хранение профилей и контента, обеспечивая быстрый доступ к данным и удобство обмена информацией. Кроме того, платформа решает задачу безопасного хранения пользовательских данных и их защищенного доступа через токены безопасности (JWT).**Основные бизнес-требования и сценарии использования:**
- *Регистрация нового пользователя:* Неавторизованный посетитель предоставляет необходимые данные (например, имя, адрес электронной почты, пароль) через API. Система создает учетную запись, храня пароли в зашифрованном виде. **Сценарий:**  Пользователь отправляет запрос регистрации -> система проверяет корректность данных и уникальность логина/email -> создает запись пользователя в БД -> возвращает подтверждение успешной регистрации.

- *Авторизация (логин):* Пользователь вводит свои учетные данные (логин/пароль). Система проверяет их и выдает JWT токен, который будет использоваться для последующих запросов. **Сценарий:**  Пользователь отправляет запрос на логин с логином и паролем -> система сверяет хэш пароля с хранимым -> при успехе генерирует JWT токен с информацией о пользователе и сроком действия -> возвращает токен клиенту.

- *Просмотр и редактирование профиля:* Авторизованный пользователь запрашивает свои данные профиля или обновляет их (например, меняет статус, фотографию профиля и т.п.). **Сценарий:**  Клиент запрашивает данные профиля через GET `/api/users/{id}` -> система возвращает информацию (кроме чувствительных данных, таких как пароль). Для редактирования клиент отправляет PUT-запрос с изменениями -> система валидирует JWT (чтобы пользователь мог менять только свой профиль) -> обновляет соответствующие поля в БД.

- *Поиск других пользователей:* Пользователь ищет людей по имени/электронной почте/другим параметрам. **Сценарий:**  Отправляется GET-запрос на `/api/users?search=<query>` -> система выполняет поиск по индексированным полям (например, имени пользователя) -> возвращает список подходящих профилей (ограниченный по количеству, с пагинацией).

- *Добавление в друзья:* Пользователь отправляет запрос на добавление другого пользователя в друзья. **Сценарий:**  Клиент (пользователь A) вызывает POST `/api/users/{A}/friends/{B}` -> система проверяет, что A имеет право отправить запрос (A == аутентифицированный пользователь) и что B существует -> создает "запрос дружбы" (в БД помечается, что пользователь B имеет входящий запрос от A) -> возвращает статус. Пользователь B может затем подтвердить дружбу: PATCH или POST запрос подтверждения -> система обновляет статус связи на "друзья". После подтверждения оба пользователя становятся друзьями друг другу.

- *Публикация поста:* Пользователь создает новый пост (запись) в своей хронике. **Сценарий:**  Авторизованный клиент делает POST `/api/posts` с содержимым поста (JSON с текстом, ссылками на изображения и т.д.) -> система валидирует JWT, извлекает из токена ID пользователя-автора -> сохраняет новый пост в БД, связывая с ID автора, устанавливает время создания -> возвращает данные созданного поста (включая сгенерированный ID, время).

- *Просмотр ленты новостей:* Пользователь просматривает ленту постов от своих друзей. **Сценарий:**  Клиент запрашивает GET `/api/users/{id}/feed` -> система аутентифицирует пользователя (id должно совпадать с токеном или токен имеет право на просмотр) -> система находит всех друзей пользователя {id} -> выбирает последние посты этих друзей из базы, сортирует по времени (с использованием SQL или на уровне сервиса) -> возвращает список постов в формате JSON (с возможностью разбивки на страницы, например, передача параметров `page` и `size`).

- *Лайки и комментарии:* Пользователь ставит "лайк" на пост или пишет комментарий. **Сценарий лайка:**  Клиент отправляет POST `/api/posts/{postId}/like` -> система удостоверяется, что пользователь (из JWT) не лайкал этот пост ранее -> создает запись лайка (связь между пользователем и постом) -> возможно, увеличивает счетчик лайков у поста -> возвращает успех. **Сценарий комментария:**  Клиент POST `/api/posts/{postId}/comments` с текстом комментария -> система проверяет токен -> сохраняет комментарий (связав с постом и автором комментария) -> возвращает данные нового комментария.

- *Уведомления:* (Опционально) Например, когда пользователь получает новый запрос в друзья или его пост прокомментировали, система создает уведомление. Пользователь может запросить свои уведомления: GET `/api/notifications` -> система возвращает список непрочитанных уведомлений. (Реализация уведомлений может быть отложена или упрощена, например, путём периодического опроса со стороны клиента).

- *Администрирование:* (Если входит в скоп проекта) Администраторы могут удалять контент, блокировать пользователей. Это предполагает роль "ADMIN" в системе. **Сценарий:**  Админ делает DELETE запрос на `/api/posts/{postId}` -> система проверяет роль из JWT -> удаляет пост и связанные комментарии/лайки из базы.
  **Ограничения:**  В рамках данного ТЗ реализация **реального времени**  (например, мгновенного обновления ленты или чата) не рассматривается – взаимодействие происходит посредством запросов к API. Мобильные push-уведомления или email-оповещения также вне рамок данного проекта. Фокус – на разработке надежного серверного ядра социальной сети, которое может масштабироваться и быть расширено при необходимости.
## 3. Технологический стек
**Java Core + Spring:**  Проект будет реализован на языке **Java**  (версия 17, LTS, либо актуальная стабильная версия) с использованием экосистемы **Spring** . Выбор обусловлен следующими причинами:
- Java – производительный, масштабируемый язык, богатый экосистемой библиотек и фреймворков, хорошо подходящий для серверных приложений. Позволяет использовать ООП-модели для сущностей социальной сети.

- **Spring Boot**  ускоряет разработку, предоставляя готовую инфраструктуру для создания standalone веб-приложений. Он упрощает настройку за счет автоконфигурации.

- **Spring MVC/Web**  (в составе Boot) облегчит создание REST API контроллеров и маршрутизацию HTTP-запросов. Аннотации (@RestController, @RequestMapping и др.) позволяют быстро описать API.

- **Spring Data JPA**  (Hibernate) предоставляет ORM для удобной работы с базой данных на уровне Java-объектов. Это ускоряет разработку доступа к данным (репозитории, CRUD операции) и уменьшает количество шаблонного кода SQL.

- **Spring Security**  обеспечит безопасность приложения: аутентификацию и авторизацию. В связке с JWT (JSON Web Token) Spring Security позволит легко защитить REST API эндпоинты, требуя токены от клиентов и проверяя их.

- **Spring Cloud (Netflix OSS)**  может использоваться для реализации API Gateway и других паттернов микросервисов (например, для регистрации сервисов, circuit breaker). В частности, **Spring Cloud Gateway**  выбран для реализации API Gateway, так как он интегрируется со Spring Security и поддерживает JWT.
  **Hibernate / JPA:**  используется как реализация JPA для взаимодействия с **реляционной базой данных (PostgreSQL)** . Hibernate берет на себя преобразование Java-сущностей (классов Entity) в таблицы и SQL-запросы, что ускоряет разработку и обеспечивает поддержку транзакционности. Выбор JPA/Hibernate также облегчает переносимость кода между разными СУБД при необходимости.**SQL и база данных (PostgreSQL):**  В качестве СУБД выбрана **PostgreSQL**  по следующим причинам:
- PostgreSQL – открытая и мощная реляционная СУБД, которая хорошо масштабируется и поддерживает сложные запросы, транзакции, хранимые процедуры.

- Социальная сеть генерирует связные данные (пользователи, связи, посты, лайки и т.д.), которые удобно хранить в реляционной модели с четкими отношениями (связи один-ко-многим, многие-ко-многим).

- Поддерживается Hibernate (через JDBC драйвер), имеется опыт использования в продакшене.

- Требования к согласованности данных (например, нельзя допустить "полудобавленного" пользователя или поста) легко обеспечиваются транзакциями ACID, которые предоставляет PostgreSQL.

- Будет спроектирована структура базы данных с учетом индексов на часто запрашиваемые поля (например, индекс по полю username для быстрого поиска пользователей, индексы по внешним ключам для ускорения джоинов). Используются **внешние ключи**  для обеспечения ссылочной целостности (например, пост всегда ссылается на существующего пользователя-автора).

- Предусмотрено использование транзакций при групповых операциях (например, добавление дружбы — две связанные записи — будет обернуто в транзакцию).
  **REST API:**  Для взаимодействия с клиентами (и между микросервисами) используется архитектурный стиль **REST**  поверх HTTP. Формат передаваемых данных – **JSON**  (JavaScript Object Notation) как легковесный и широко поддерживаемый формат. Все сервисы предоставляют четко определенные REST-эндпоинты с понятными URL, использованием соответствующих HTTP методов (GET для получения данных, POST для создания, PUT/PATCH для обновления, DELETE для удаления). Каждый запрос/ответ имеет определенную JSON-структуру (описана в спецификации API ниже). Для документирования API будет применен **OpenAPI (Swagger)** : это облегчит поддержку и тестирование, позволяя генерировать интерактивную документацию.**Docker (контейнеризация и деплой):**  Для упрощения развертывания и поддержки консистентной среды исполения, проект использует **Docker** :
- Каждая микросервисная компонента (см. раздел *Архитектура проекта*) упакована в отдельный Docker-образ. Образы основаны на официальном **OpenJDK**  runtime для Java.

- Использование Docker гарантирует, что приложение будет работать одинаково в средах разработки, тестирования и продакшена, устраняя проблемы "работает на моей машине".

- Контейнеризация упрощает масштабирование: можно запускать несколько контейнеров одного сервиса за балансировщиком нагрузки.

- **Docker Compose**  будет использоваться для локального запуска всего набора сервисов (микросервисы + база данных + возможно другие компоненты) одной командой. В Compose файле описаны все сервисы и их связь (например, сервисы зависят от контейнера с БД).

- В продакшене контейнеры могут быть развёрнуты на одном или нескольких узлах. Возможно использование оркестрации (Kubernetes) в будущем, но в рамках данного ТЗ предполагается Docker Compose или аналог для демонстрации работы системы.
  **Тестирование (JUnit, Mockito):**
- Для модульного тестирования логики используются **JUnit 5**  (Jupiter) фреймворк, а для имитации зависимостей – **Mockito** .

- Тесты позволят проверять корректность работы сервисов (например, правильность бизнес-логики методов) в изоляции.

- Spring Boot также предоставляет удобства для тестирования, например аннотации @SpringBootTest, @WebMvcTest, а также встроенные средства для поднятия контекста и использования in-memory баз (H2) для интеграционного тестирования JPA.

- Покрытие кода тестами – один из требований качества, поэтому на критичные компоненты (сервисы, утилиты, безопасность) будут написаны тест-кейсы.
  **Spring Security + JWT:**
- Безопасность – ключевой аспект. Используется **Spring Security**  для реализации аутентификации и авторизации, а также **JWT (JSON Web Tokens)**  для безсессионной аутентификации.

- При логине генерируется JWT токен (подписанный HS256 или RS256 ключом). Токен включает в себя идентификатор пользователя и, возможно, роль (например, ROLE_USER, ROLE_ADMIN).

- Токен отправляется клиенту, а клиент прикрепляет его к каждому последующему запросу в заголовке `Authorization: Bearer <JWT>`.

- Spring Security на стороне сервера настроен на проверку JWT: для этого используется фильтр, который перехватывает запросы, валидирует подпись и срок действия токена, извлекает информацию о пользователе.

- Также Spring Security обеспечивает **role-based**  ограничение доступа к определенным эндпоинтам (например, админ-эндпоинты закрыты от обычных пользователей).

- **API Gateway**  (шлюз) тоже интегрируется с Spring Security, выступая первой линией проверки JWT для всех входящих запросов.
  **Микросервисная архитектура:**
- Система будет разделена на несколько **микросервисов**  (см. след. раздел), каждый из которых отвечает за определенную область данных или функциональности (Auth, Пользователи, Посты и т.д.).

- Микросервисы взаимодействуют через легковесные механизмы – в основном REST API друг друга (с использованием внутренних защищенных вызовов).

- **API Gateway**  служит единым входом в систему, получая запросы от клиентов и перенаправляя их в нужный микросервис. Это позволяет скрыть внутреннюю структуру сервисов от внешних клиентов и централизовать кросс-сервисные проблемы (аутентификация, агрегирование данных, CORS).

- Для конфигурации и консистентности версий между микросервисами используется **Git**  (Gitflow рабочий процесс, см. ниже) и возможны инструменты Spring Cloud Config (в перспективе, для централизованной конфигурации) – но базово настройки для каждого сервиса хранятся в его application.properties/yaml или через переменные окружения (что поддерживается Docker Compose).

- Микросервисный подход обеспечивает гибкость масштабирования: при увеличении нагрузки на конкретный сервис (например, сервис постов), мы можем масштабировать именно его, не трогая остальные. Также облегчается поддержка – небольшие кодовые базы, сфокусированные на одной задаче.
  **Система контроля версий (Git):**
- Код проекта хранится в репозитории **Git** . Для командной работы принят workflow **Gitflow** : отдельные ветки для разработки новых функций, интеграционная ветка develop, стабильная главная ветка main (master) для релизов и релизные/горячие фикс-ветки при необходимости.

- Такой подход позволит параллельно нескольким разработчикам вести работу и интегрировать изменения поэтапно, с код-ревью через Pull Request.

- Каждое существенное изменение сопровождается информативным коммит-сообщением, соответствующим стандартам (например, указание типа изменения: feature, fix, docs и краткое описание).

- Репозиторий также хранит документацию (в README.md, Wiki) и, возможно, спецификации API (в Swagger/OpenAPI формате JSON/YAML).

## 4. Архитектура проекта
**Общая структура:**  Проект построен по **микросервисной архитектуре** . Предполагается разделение на следующие основные сервисы:
- **API Gateway**  – Шлюз API, единая точка входа для всех клиентов. Он принимает все внешние HTTP-запросы и на основе URL/маршрута и правил безопасности перенаправляет их к нужному внутреннему сервису. Gateway осуществляет проверку JWT (аутентификацию) для защищенных маршрутов, а также может выполнять агрегирование ответов от нескольких сервисов (если требуется) или простую маршрутизацию.

- **Auth Service**  – Сервис аутентификации и авторизации. Отвечает за вход пользователя в систему: проверяет учетные данные и выдает JWT. В перспективе может отвечать за refresh-токены, logout (инвалидация токенов, хотя JWT по природе самодостаточный и хранилища не требует) и управление доступом. Может работать совместно с пользовательским сервисом (чтобы получать/создавать учетные данные).

- **User Service**  – Сервис управления пользователями. Ведает всеми операциями, связанными с профилями пользователей: регистрация нового пользователя, получение и изменение данных профиля, управление дружбой (отправка запросов, принятие, список друзей). Хранит информацию о пользователях и их социальном графе (друзьях).

- **Post Service**  – Сервис управления постами (контентом). Обрабатывает создание, редактирование, удаление постов, выдачу ленты новостей. Также включает функциональность взаимодействия с постами: комментарии и лайки (возможно как подсервисы или внутри этого же сервиса для упрощения). Хранит все публикации пользователей, их комментарии, и связи "пост-лайк" в своей базе.

- **Notification Service**  – (опционально) Сервис уведомлений. Отвечает за формирование и доставку уведомлений пользователям о различных событиях (новый друг, новая реакция на пост и др.). Может реализовываться через асинхронные механизмы (например, помещать события в очередь сообщений Kafka/RabbitMQ, а затем отправлять уведомления).

- **Дополнительные сервисы**  – при необходимости архитектура может быть расширена отдельными микросервисами: например, **Comment Service**  или **Like Service**  (если выделять из Post Service), **Search Service**  (для полнотекстового поиска по постам/профилям, возможно на основе ElasticSearch, но это вне рамок базового функционала), **Admin Service**  (для администрирования, или эти функции могут быть включены в User/Post сервисы с проверкой роли).
  **API Gateway и маршрутизация:**  API Gateway (возможно реализованный на Spring Cloud Gateway) содержит маршруты, которые соответствуют эндпоинтам микросервисов. Например:
- Запросы, начинающиеся с `/api/auth/**` направляются на Auth Service.

- Запросы к `/api/users/**` идут на User Service.

- Запросы к `/api/posts/**` – на Post Service.

- (Если Notification Service имеет внешние эндпоинты, например `/api/notifications/**` – на Notification Service).
  Gateway также интегрирован со **Spring Security** : перед перенаправлением запроса он проверяет наличие и валидность JWT токена, удостоверяется, что у пользователя есть нужные права для запрошенного ресурса. Например, запрос на `/api/admin/**` может требовать роль ADMIN в токене – Gateway проверит это и либо пропустит, либо вернет 403 Forbidden без дерганья внутреннего сервиса.
  **Взаимодействие микросервисов:**  Общая схема предполагает, что большинство операций выполняются внутри одного сервиса. Однако некоторые сценарии требуют межсервисного взаимодействия:
- Пример: при логине Auth Service должен проверить учетные данные пользователя. Возможны два подхода:
    1. Auth Service имеет доступ к базе данных пользователей (только к таблице учетных данных) напрямую.

    2. Auth Service обращается к User Service по внутреннему API, запрашивая пользователя по логину и получая хэш пароля для проверки.
       Выбирается второй подход, чтобы соблюсти **принцип единственной ответственности**  – User Service владеет данными пользователей. Auth Service шлет внутренний запрос (например, REST или gRPC) к User Service: "дай пользователя с логином X". User Service возвращает данные, Auth Service сверяет пароль и генерирует JWT. Этот подход несколько увеличивает задержку на логин, но разделяет обязанности четко.

- Другой пример: Post Service при формировании ленты получает список друзей пользователя. Здесь Post Service может запросить у User Service список идентификаторов друзей. Затем Post Service делает запрос к своей базе по этим ID. **Альтернатива:**  поддерживать в Post Service кэш или реплицированные данные, но в первой версии проще сделать межсервисный запрос.

- Если Notification Service внедрен, он может получать события из других сервисов. Например, после того как Post Service сохраняет новый комментарий, он может отправить сообщение (через REST или сообщение в брокер) Notification-сервису: "для пользователя X событие: ваш пост прокомментирован". Notification Service тогда сохраняет уведомление и/или рассылает его.
  **Схема микросервисов:**  (логическое описание без рисунка)
- **Client (Web/Mobile)**  → **API Gateway**  → маршруты:
    - `/api/auth/*` → **Auth Service**

    - `/api/users/*` → **User Service**

    - `/api/posts/*` → **Post Service**

    - `/api/notifications/*` → **Notification Service**  (если реализован)

- **Внутренние связи:**
    - Auth Service ↔ User Service (взаимодействие при регистрации и аутентификации)

    - Post Service → User Service (запросы списка друзей, профилей при необходимости)

    - (Post Service → Notification Service, User Service → Notification Service для событий уведомлений)

    - Все сервисы могут иметь доступ к общей инфраструктуре (например, к очереди сообщений, к сервису конфигурации, к мониторингу).
      **Примечание:**  На первом этапе можно не внедрять брокеры сообщений или динамическое обнаружение сервисов (Service Registry). Маршруты Gateway настроены статически, URL внутренних сервисов фиксированы (например, `USER_SERVICE_HOST` и т.д. заданы в переменных окружения Docker). Это упростит реализацию. В дальнейшем возможна интеграция **Eureka**  или **Consul**  для автоматического обнаружения и балансировки между экземплярами микросервисов.
## 5. Описание модулей/микросервисов

Ниже описана функциональность каждого микросервиса (модуля) и формат данных, с которыми он работает:
**1. Auth Service (Сервис аутентификации):**
- **Назначение:**  Управление входом в систему и выдачей токенов. Необходим для безопасности – отделяет процесс проверки логина/пароля и генерации JWT от остальных сервисов.

- **Основные функции:**
    - **Login:**  Проверка предоставленного логина и пароля пользователя. Если они корректны – генерация JWT токена и возврат его клиенту. JWT содержит идентификатор пользователя и роли, подписан секретным ключом (HS256) или парой ключей (RS256).

    - **Token Refresh (опционально):**  Выпуск нового JWT по истечении старого с использованием refresh-токена (требует реализации хранения/проверки refresh-токенов, возможно не реализуется в первой версии).

    - **Logout (опционально):**  В случае JWT, логаут на сервере обычно не нужен (клиент просто забывает токен). Однако может вестись "чёрный список" отозванных токенов (например, если нужно принудительно завершить сессии).

- **Взаимодействие с другими сервисами:**
    - При логине Auth Service должен получить данные пользователя. Он будет обращаться в User Service по внутреннему API: запрашивать пользователя по имени или email.

    - Если пользователь не найден или пароль не совпадает – возвращается ошибка.

    - При успешном логине – Auth Service создает JWT самостоятельно (внутри себя, используя библиотеку JWT).

- **Формат данных:**
    - **Запрос логина**  ожидает JSON с полями `{ "username": "...", "password": "..." }`.

    - **Ответ при успешном логине** : JSON с токеном, например `{ "token": "<JWT>", "expires": "<ISO8601 datetime>" }`. Токен – строка (типично ~от eyJhbGciOi...).

    - **Ответ при ошибке аутентификации** : код 401 Unauthorized и сообщение об ошибке в JSON `{ "error": "Invalid credentials" }`.

    - Auth Service сам по себе не хранит больших данных, кроме, возможно, ключей для подписи токенов (или секретной фразы). Пользовательские данные хранятся в User Service.
      **2. User Service (Сервис пользователей):**
- **Назначение:**  Управление учетными записями пользователей и их социальными связями.

- **Основные функции:**
    - **Регистрация пользователя:**  Создание новой учетной записи. User Service получает данные нового пользователя (имя, email, пароль и т.д.), валидирует их (уникальность email/логина), хэширует пароль (например, BCrypt) и сохраняет запись в БД. Возвращает созданного пользователя (или сокращенные данные) при успехе.

    - **Получение профиля:**  Предоставляет информацию профиля по запросу. Может различать собственный профиль (с полной информацией) и чужой профиль (с общедоступной информацией, без личных данных).

    - **Обновление профиля:**  Изменение данных – например, изменение статуса, загрузка аватара (в бэкенде – сохранение ссылки на аватар, сам файл мог бы храниться во внешнем объектном хранилище).

    - **Управление дружбой:**
        - Отправка запроса дружбы: сохранение записи "в ожидании" между пользователями (заявка).

        - Принятие/отклонение заявки: изменение статуса существующей записи или создание взаимных записей дружбы.

        - Удаление из друзей: удаляет связь между двумя пользователями.

        - Получение списка друзей, входящих заявок, исходящих заявок.

    - **Поиск пользователей:**  Поиск по имени, email или другим атрибутам (с использованием SQL `LIKE` или полнотекстового поиска при увеличении требований).

- **Взаимодействие:**
    - User Service получает запросы от Gateway, проверяет JWT (Spring Security) на валидность и извлекает оттуда userId для операций, связанных с текущим пользователем.

    - При успешной регистрации нового пользователя может уведомлять Auth Service (в базовой версии не обязательно) или просто позволяет Auth Service сразу использовать новые данные.

    - При запросах дружбы, User Service может уведомлять Notification Service о новых заявках (если уведомления реализованы).

    - Также, если Post Service запрашивает информацию о пользователях (имя, аватар) для отображения в ленте, User Service предоставляет необходимый API (например, batch-запрос: получить информацию о нескольких пользователях по их ID).

- **Хранение данных:**  PostgreSQL таблица пользователей и таблица связей (дружбы). Подробно структура – в разделе БД.

- **Формат данных:**  Все обмены – JSON.
    - Данные пользователя в ответах: например, `{ "id": 123, "username": "john_doe", "name": "John Doe", "bio": "Hello!", "avatarUrl": "/media/avatars/123.jpg" }`. (Без поля пароля, конечно.)

    - Запрос на обновление профиля может принимать частичный JSON с изменяемыми полями (имя, био).

    - Дружба: заявка может быть представлена как объект `{ "id": 555, "fromUser": 123, "toUser": 456, "status": "PENDING" }` или просто имплицитно через эндпоинт.
      **3. Post Service (Сервис постов):**
- **Назначение:**  Управление социальным контентом – постами, лентой, а также реакциями (лайками) и комментариями к постам.

- **Основные функции:**
    - **Создание поста:**  Пользователь публикует новый пост. Сервис сохраняет пост в своей базе, включая содержимое, автора (ID пользователя), время создания. Возвращает созданный пост.

    - **Получение поста:**  По запросу возвращает содержимое конкретного поста (текст, автор, время, количество лайков, последние комментарии или число комментариев).

    - **Удаление/редактирование поста:**  Автор поста может отредактировать содержимое (например, исправить текст) или удалить пост. При удалении также удаляются связанные лайки и комментарии (в рамках данного сервиса).

    - **Лента новостей:**  Отдает список постов друзей. Реализуется запросом: сервис получает от User Service список друзей запрашивающего пользователя, затем делает выборку постов этих друзей, сортирует по дате. Добавляется пагинация (например, по 20 постов на страницу, с параметрами page, size).

    - **Лайки:**
        - Добавление лайка к посту: создает запись (userId, postId) в таблице лайков. Можно возвращать обновленный счетчик.

        - Удаление лайка (повторный запрос может снимать лайк).

        - Получение всех лайков поста (список пользователей, пролайкавших пост) – возможно не критично для UI, но API может предоставить.

    - **Комментарии:**
        - Добавление комментария к посту: сохраняет комментарий с указанием автора (userId), поста (postId), текста, времени.

        - Удаление или редактирование комментария – автор комментария или автор поста (для модерации) может удалить.

        - Получение комментариев поста (с пагинацией, если их много).

- **Взаимодействие:**
    - Post Service при формировании ленты обращается к User Service (список друзей) или может требовать от клиента передавать список (плохой вариант, лучше сервис сам).

    - При отображении поста, если нужны детали автора или комментаторов, Post Service может либо хранить часть информации (например, username автора в посте для быстрой отдачи), либо запрашивать User Service при необходимости. В первом приближении, Post Service хранит только userId, а клиент при необходимости может допрашивать User Service для получения имен. (В дальнейшем можно оптимизировать денормализацией – хранить username копией.)

    - Post Service также может взаимодействовать с Notification Service: например, при новом комментарии – уведомить автора поста.

- **Хранение данных:**  Своя PostgreSQL база (или схема) с таблицами постов, комментариев, лайков. Структура – см. раздел БД.

- **Формат данных:**  JSON:
    - Пример объекта поста в ответе:

```json
{
  "id": 101,
  "authorId": 123,
  "content": "Это мой первый пост!",
  "createdAt": "2025-02-22T10:15:30",
  "likesCount": 5,
  "commentsCount": 2
}
```
(При необходимости можно возвращать вложенный объект автора, но тогда Post Service должен знать детали или клиент должен запрашивать отдельно).

- Для создания/редактирования поста клиент отправляет JSON с требуемыми полями, например `{ "content": "Новый текст поста" }` на соответствующий эндпоинт.

- Комментарий может быть представлен как `{ "id": 301, "postId": 101, "authorId": 456, "text": "Привет!", "createdAt": "2025-02-22T11:00:00" }`.

- Запрос лайка не требует тела – только идентификация пользователя через JWT.
  **4. Notification Service (Сервис уведомлений, опционально):**
- **Назначение:**  Уведомление пользователей о событиях (необязательно для первого релиза, но учитывается в архитектуре).

- **Основные функции:**  Принимать события из других сервисов (новый пост друга, лайк, комментарий, запрос дружбы) и создавать записи уведомлений. По запросу клиента – возвращать список уведомлений.

- **Реализация:**  Может слушать сообщения из брокера (Kafka/RabbitMQ) или предоставлять REST API для вызова другими сервисами. Например, Post Service может вызывать `POST /internal/notify` на Notification Service.

- **Хранение:**  Таблица уведомлений (notification) с полями: id, userId (кому), type (тип события), reference (ссылка на объект события: например, пост или пользователь), текст или шаблон сообщения, флаг прочитано/непрочитано, время.

- **Формат данных:**  JSON, например уведомление: `{ "id": 900, "userId": 123, "type": "FRIEND_REQUEST", "message": "Пользователь Ivan отправил вам запрос дружбы", "read": false, "createdAt": "2025-02-22T12:00:00" }`.
  **5. API Gateway:**
- **Назначение:**  Центральный маршрутизатор запросов от клиентов к микросервисам. Обеспечивает единый домен/адрес для внешнего обращения и скрывает внутренние адреса сервисов.

- **Функции:**
    - **Маршрутизация:**  Перенаправление запросов на основе правил (шаблонов URL) к целевому сервису. Например, реализовано с помощью конфигурации Spring Cloud Gateway: routes YAML, либо Java-конфигурации RouteLocator.

    - **Аутентификация и авторизация:**  Внедрена фильтрация запросов – Gateway проверяет JWT токен (если требуется для данного URL). Это делается глобально, чтобы не дублировать логику проверки в каждом сервисе. Однако **вопрос безопасности** : можно настроить так, что Gateway валидирует JWT и проксирует запрос дальше, добавляя, например, заголовок с userId или просто передавая тот же JWT. Внутренние сервисы могут доверять, что если запрос прошел через Gateway, он уже авторизован. Тем не менее, для дополнительной безопасности обычно **каждый сервис**  также самостоятельно проверяет JWT (особенно если можно миновать Gateway; но при правильной инфраструктуре миновать Gateway извне нельзя).

    - **SSL/TLS:**  Gateway может терминировать SSL-соединения (HTTPS) на себе, обеспечивая шифрование трафика с клиентами. Внутренние связи микросервисов могут быть в доверенной сети и идти по HTTP.

    - **CORS и ограничение доступа:**  Gateway настроен отдавать корректные CORS заголовки для фронтенд-приложений (разрешая нужные источники, методы). А также может ограничивать доступ к определенным ресурсам (например, IP-фильтрация, rate limiting в целях защиты от DDoS).

    - **Логирование и трейсинг:**  Gateway будет логировать входящие запросы, исходящие к сервисам, время обработки – для целей мониторинга. Можно внедрить корреляционные ID (например, traceId) чтобы отслеживать запрос через все сервисы.

- **Формат данных:**  Gateway в идеале прозрачен – он просто пересылает JSON запросы и ответы. Никакой трансформации данных (кроме агрегаций, если бы требовалось) не происходит. То есть, формат запросов/ответов определяется микросервисами; Gateway лишь добавляет заголовки (например, `X-User-ID` после аутентификации) или убирает внутренние заголовки.
  **Формат обмена данными между сервисами:**
- Используются синхронные REST вызовы через HTTP внутри внутренней сети (например, User Service поднимается на `http://user-service:8081/`, Post Service `http://post-service:8082/` и Gateway знает эти адреса). Формат данных тоже JSON. Для безопасности внутренние запросы могут содержать специальный сервисный токен или заголовок API-ключа, хотя если они изолированы в докер-сети, можно считать их доверительными.

- Возможны асинхронные коммуникации: например, Notification Service может подписаться на события. Если внедряется брокер сообщений (не в первой итерации), формат сообщений – JSON (схема оговаривается, например, событие "NEW_COMMENT" содержит postId, authorId, текст и т.д.).

Таким образом, каждый модуль чётко отвечает за свой участок функционала, что облегчает сопровождение и масштабирование. Ниже приведены спецификации API и структура базы данных, детализирующие взаимодействие и хранение.

## 6. RestAPI-спецификация
В этом разделе описываются основные REST API эндпоинты для каждого сервиса: URL, методы, параметры, структура запросов и ответов, а также коды ответов сервера. Формат данных – JSON. Все URL указаны с учетом маршрутизации через API Gateway (т.е. внешние для клиента). Предполагается префикс `/api` для всех маршрутов.**6.1 Auth Service API:**
- **POST**  `/api/auth/register` – *Регистрация нового пользователя.*
  **Описание:**  Создает новую учетную запись пользователя.
  **Тело запроса:**  JSON с обязательными полями, например:

```json
{
  "username": "john_doe",
  "email": "john@example.com",
  "password": "securePassword"
}
```
**Ответ:**  При успешной регистрации – код 201 Created. Тело ответа может содержать профиль нового пользователя (либо минимальную информацию):

```json
{
  "id": 123,
  "username": "john_doe",
  "email": "john@example.com"
}
```
Пароль не возвращается. Также возможен автоматический вход – например, сразу вернуть JWT токен (опционально).
**Коды ответов:**  201 (Created), 400 (Bad Request, если данные не валидны, например, короткий пароль или занятый username/email), 409 (Conflict, если пользователь с таким именем/почтой уже существует).

- **POST**  `/api/auth/login` – *Аутентификация (вход).*
  **Описание:**  Проверяет логин и пароль пользователя, выдаёт JWT при успешной аутентификации.
  **Тело запроса:**  JSON с полями для входа (либо `username`+`password`, либо `email`+`password`, в зависимости от того, как пользователь идентифицируется – допустим, логин):

```json
{
  "username": "john_doe",
  "password": "securePassword"
}
```
**Ответ:**  При успешной проверке возвращается JWT токен:

```json
{
  "token": "<JWT字符串>",
  "tokenType": "Bearer",
  "expiresIn": 3600
}
```
где `token` – сам JWT, `tokenType` указывает тип (для клиента, обычно Bearer), `expiresIn` – время жизни токена в секундах.
Токен также может передаваться через заголовки ответа (`Authorization: Bearer <token>`).
**Коды ответов:**  200 (OK – успешный вход), 401 (Unauthorized – неверные учетные данные), 400 (если запрос неверен по формату).
**Примечание:**  После получения токена, клиент должен использовать его в заголовке `Authorization` для всех защищенных запросов.

- *(Опционально)* **POST**  `/api/auth/refresh` – *Обновление JWT токена.*
  **Описание:**  Выдает новый JWT по действующему refresh-токену. Требует отправить refresh-токен (выданный при логине) и возвращает новый access-token.
  **Тело запроса:**  `{ "refreshToken": "<refresh_jwt>" }`.
  **Ответ:**  `{ "token": "<new_access_jwt>", "expiresIn": 3600 }`.
  **Коды:**  200 (OK), 401 (если refresh недействителен).
  **6.2 User Service API:**
- **GET**  `/api/users/{id}` – *Получить профиль пользователя.*
  **Описание:**  Возвращает информацию профиля пользователя с идентификатором `{id}`.
  **Требует авторизации:**  Доступно для авторизованных пользователей. Если `{id}` совпадает с ID текущего пользователя – можно возвращать полную инфу, иначе – ограниченную (нет email, приватных полей).
  **Ответ:**  200 OK с телом:

```json
{
  "id": 123,
  "username": "john_doe",
  "name": "John Doe",
  "bio": "Hello, I'm John!",
  "avatarUrl": "/media/avatar123.jpg",
  "friendsCount": 50,
  "postsCount": 10
}
```
**Коды ошибок:**  404 (Not Found – если пользователь не найден), 403 (Forbidden – если доступ запрещен, например, запрашивают чужие приватные данные).

- **PUT**  `/api/users/{id}` – *Обновить профиль пользователя.*
  **Описание:**  Изменяет данные профиля пользователя `{id}`. Пользователь должен быть авторизован и иметь право редактировать этот профиль (или админ).
  **Тело запроса:**  JSON с полями, которые нужно изменить. Например:

```json
{
  "name": "Johnathan Doe",
  "bio": "Обновлённое описание профиля"
}
```
(email и username обычно не позволяют менять, либо требуют отдельной процедуры; здесь – по усмотрению.)
**Ответ:**  200 OK с обновленными данными профиля (или 204 No Content без тела).
**Коды ответов:**  200 (OK), 400 (невалидные данные), 401 (не авторизован), 403 (нет прав – пытается изменить чужой профиль), 404 (пользователь не найден).

- **GET**  `/api/users?search={query}` – *Поиск пользователей.*
  **Описание:**  Ищет пользователей по имени или логину, содержащим подстроку `{query}`. Доступно авторизованным.
  **Параметры:**  `query` – строка поиска; пагинация: `page`, `size`.
  **Ответ:**  200 OK, тело – список пользователей (может быть сокращенный формат):

```json
{
  "results": [
    { "id": 123, "username": "john_doe", "name": "John Doe", "avatarUrl": "/avatar123.jpg" },
    { "id": 124, "username": "jane", "name": "Jane Smith", "avatarUrl": "/avatar124.jpg" }
  ],
  "page": 1,
  "size": 20,
  "total": 2
}
```
**Коды ошибок:**  400 (если параметр отсутствует или некорректен).

- **POST**  `/api/users/{id}/friends/{friendId}` – *Отправить запрос на добавление в друзья.*
  **Описание:**  Аутентифицированный пользователь `{id}` отправляет запрос пользователю `{friendId}`. По сути создается заявка в друзья.
  **Права:**  `{id}` должно совпадать с ID в JWT (пользователь посылает заявку от своего имени).
  **Тело запроса:**  (не требуется, вся информация в URL и токене).
  **Ответ:**  200 OK или 201 Created, тело может содержать объект дружбы или подтверждение:

```json
{ "status": "REQUEST_SENT" }
```
**Коды ответов:**  201 (если создана новая запись заявки), 400 (если уже отправлен запрос или попытка добавить самого себя), 401 (не авторизован), 404 (если пользователь friendId не найден).

- **GET**  `/api/users/{id}/friends` – *Получить список друзей пользователя.*
  **Описание:**  Возвращает список пользователей, являющихся друзьями пользователя `{id}`.
  **Ответ:**  200 OK, тело:

```json
{
  "friends": [
     { "id": 124, "username": "jane", "name": "Jane Smith", "avatarUrl": "/avatar124.jpg" },
     ...
  ],
  "count": 50
}
```
**Замечание:**  Если `{id}` совпадает с текущим пользователем – вернет весь список друзей. Если нет и профиль приватный – можно вернуть ошибку 403 или пустой список/только общих друзей.

- **POST**  `/api/users/{id}/friends/{friendId}/accept` – *Принять запрос в друзья.*
  **Описание:**  Пользователь `{id}` принимает заявку от пользователя `{friendId}`. Сервис обновляет связь, теперь пользователи друзья.
  **Ответ:**  200 OK `{ "status": "FRIENDS" }` (или возвращает обновленную запись дружбы).
  **DELETE**  `/api/users/{id}/friends/{friendId}` – *Удалить из друзей/отклонить заявку.* – аналогично, меняет статус или удаляет связь, возвращает 200 OK.

- *(Дополнительно)* **GET**  `/api/users/{id}/requests` – получить список входящих заявок в друзья для пользователя.
  **6.3 Post Service API:**
- **POST**  `/api/posts` – *Создать новый пост.*
  **Описание:**  Создает пост от имени текущего аутентифицированного пользователя.
  **Тело запроса:**  JSON с содержимым поста:

```json
{
  "content": "Текст поста...",
  "imageUrl": "http://.../image.png"  (опционально, если есть изображение)
}
```
**Ответ:**  201 Created, тело – созданный пост:

```json
{
  "id": 101,
  "authorId": 123,
  "content": "Текст поста...",
  "imageUrl": "http://.../image.png",
  "createdAt": "2025-02-22T10:15:30",
  "likesCount": 0,
  "commentsCount": 0
}
```
**Коды ошибок:**  400 (невалидные данные, например, пустой контент), 401 (не авторизован).

- **GET**  `/api/posts/{postId}` – *Получить пост по ID.*
  **Описание:**  Возвращает содержимое поста с идентификатором `{postId}`.
  **Ответ:**  200 OK, тело аналогично объекту поста выше, дополнительно можно включить массив комментариев или первых N комментариев:

```json
{
  "id": 101,
  "authorId": 123,
  "content": "Текст поста...",
  "createdAt": "2025-02-22T10:15:30",
  "likesCount": 5,
  "commentsCount": 2,
  "comments": [
     { "id": 301, "authorId": 456, "text": "Комментарий", "createdAt": "2025-02-22T11:00:00" },
     ...
  ]
}
```
**Коды ошибок:**  404 (если пост не найден или удален), 403 (если пост принадлежит приватной группе или пользователь не имеет прав просмотра – но в нашей модели все посты друзей видимы, а посты не друзей, возможно, недоступны -> в дальнейшем можно разграничить видимость).

- **DELETE**  `/api/posts/{postId}` – *Удалить пост.*
  **Описание:**  Удаляет пост `{postId}`. Доступно автору поста или администратору.
  **Ответ:**  200 OK (или 204 No Content) при успешном удалении.
  **Коды ошибок:**  404 (не найден), 403 (нет прав – если не автор и не админ), 401 (не авторизован).

- **GET**  `/api/users/{id}/feed` – *Получить ленту новостей пользователя.*
  **Описание:**  Возвращает список последних постов друзей пользователя `{id}` (включая, возможно, его собственные посты или нет – скорее, отдельно для личной стены будет другой запрос).
  **Параметры:**  пагинация `page`, `size` (например, 20 постов на страницу).
  **Ответ:**  200 OK, тело – массив постов (отсортированных по дате, свежие сверху). Например:

```json
{
  "posts": [
    {
      "id": 110,
      "authorId": 124,
      "content": "Пост друга",
      "createdAt": "2025-02-22T09:00:00",
      "likesCount": 3,
      "commentsCount": 1
    },
    {
      "id": 101,
      "authorId": 123,
      "content": "Текст поста...",
      "createdAt": "2025-02-22T10:15:30",
      "likesCount": 5,
      "commentsCount": 2
    }
  ],
  "page": 1,
  "size": 20,
  "hasMore": false
}
```
**Коды ошибок:**  401 (если токен отсутствует/неверен), 403 (если пытается запросить чужую ленту, но чужая лента, вероятно, недоступна – обычно каждый просматривает только свою ленту).

- **POST**  `/api/posts/{postId}/like` – *Поставить лайк посту.*
  **Описание:**  Отметить пост как "нравится" от имени текущего пользователя.
  **Ответ:**  200 OK, тело может содержать новый счетчик лайков `{ "likesCount": 6 }` или статус.
  **Действие:**  Внутри сервис создаст запись лайка. Если лайк уже был – можно вернуть ошибку 409 (Conflict) или тихо игнорировать второй лайк.
  **Коды:**  200 (OK, в т.ч. если лайк уже существовал и ничего не меняется), 404 (если пост не найден).

- **DELETE**  `/api/posts/{postId}/like` – *Убрать лайк с поста.* (опционально, либо повторный вызов POST снимает лайк)
  **Описание:**  Удаляет отметку "нравится" текущего пользователя с поста. Возвращает новый счетчик или 200 без тела.
  **Коды:**  200, 404 (если лайка не было или пост не найден).

- **GET**  `/api/posts/{postId}/likes` – *Получить лайки поста.*
  **Описание:**  Возвращает список пользователей, лайкнувших пост. (Может использоваться для отображения "N likes" и списков).
  **Ответ:**  200 OK, например: `{ "likes": [ { "userId": 123, "username": "john_doe" }, ... ] }`. (Возможно, ограничение по количеству или пагинация).

- **POST**  `/api/posts/{postId}/comments` – *Добавить комментарий к посту.*
  **Описание:**  Создает новый комментарий к посту `{postId}` от текущего пользователя.
  **Тело запроса:**  JSON с текстом комментария, напр.: `{ "text": "Отличный пост!" }`.
  **Ответ:**  201 Created, тело – созданный комментарий:

```json
{
  "id": 310,
  "postId": 101,
  "authorId": 123,
  "text": "Отличный пост!",
  "createdAt": "2025-02-22T12:00:00"
}
```
**Коды ошибок:**  400 (пустой текст), 404 (пост не найден), 401 (не авторизован).

- **GET**  `/api/posts/{postId}/comments` – *Получить комментарии поста.*
  **Описание:**  Возвращает список комментариев для поста, по умолчанию отсортированных по времени (возможна пагинация).
  **Ответ:**  200 OK, тело, например:

```json
{
  "comments": [
    { "id": 301, "postId": 101, "authorId": 456, "text": "Комментарий", "createdAt": "2025-02-22T11:00:00" },
    { "id": 310, "postId": 101, "authorId": 123, "text": "Отличный пост!", "createdAt": "2025-02-22T12:00:00" }
  ],
  "count": 2
}
```
**Коды ошибок:**  404 (если пост не найден, либо можно возвращать пустой список если комментариев нет).

- **DELETE**  `/api/posts/comments/{commentId}` – *Удалить комментарий.*
  **Описание:**  Удаляет комментарий с идентификатором `{commentId}`. Доступно автору комментария, автору поста (владелец поста может удалять чужие комментарии под своим постом), либо администратору.
  **Ответ:**  200 OK или 204 No Content.
  **Коды ошибок:**  404 (комментарий не найден), 403 (нет прав).
*
Отлично, я составлю подробное техническое задание для разработки социальной сети на Java с использованием указанного стека технологий. В нем будут учтены все ключевые аспекты, включая архитектуру микросервисов, API, безопасность, тестирование и инфраструктуру.

Я сообщу вам, когда документ будет готов.
Research completed in 8m· 1 источник
# Техническое задание: Проект социальной сети (Backend на Java)

## 1. Общее описание проекта
**Цель и краткое описание:**  Данный проект представляет собой **бэкенд для социальной сети**  – систему, позволяющую пользователям взаимодействовать друг с другом онлайн. Проект реализован без визуальной части (без пользовательского интерфейса), предоставляя функциональность через REST API. Пользовательский интерфейс (веб или мобильное приложение) сможет обращаться к этому API для выполнения операций.**Целевая аудитория:**  Целевая аудитория – широкая: активные интернет-пользователи, желающие общаться, делиться новостями и контентом с друзьями и подписчиками. Также система может использоваться разработчиками, которые будут создавать фронтенд-приложения (веб-сайты, мобильные приложения) для конечных пользователей социальной сети.**Основной функционал:**  Платформа предоставляет следующие ключевые возможности для пользователей:
- **Регистрация и авторизация пользователей:**  создание нового аккаунта, вход в систему с проверкой учетных данных, восстановление пароля (при необходимости).

- **Управление профилем:**  создание и редактирование профиля пользователя (имя, фото аватара – в пределах бэкенда хранится только ссылка или идентификатор изображения, и др. личная информация).

- **Социальные связи:**  поиск пользователей, отправка запросов в друзья, принятие/отклонение дружбы, просмотр списка друзей.

- **Публикация контента:**  создание текстовых постов (с возможностью прикрепления медиа – **в данном проекте фокус на бэкенде** , поэтому медиа может представляться ссылкой или хранилищем в будущем), редактирование и удаление своих постов.

- **Лента новостей:**  формирование и выдача ленты постов от друзей/подписок пользователя в порядке времени создания (с пагинацией).

- **Взаимодействие с постами:**  возможность ставить "лайки" постам, оставлять комментарии.

- **Уведомления:**  (опционально) рассылка уведомлений пользователям о важных событиях – например, новый запрос в друзья, новый лайк или комментарий к посту.

- **Администрирование:**  (опционально) роль администратора для модерации контента и управления пользователями.
  Все функции предоставляются через **RESTful API** . Проект реализован на языке Java с использованием фреймворка Spring Boot и сопутствующих технологий, с хранением данных в реляционной базе PostgreSQL. Визуальная часть (интерфейс) не входит в рамки данного ТЗ, однако API спроектирован так, чтобы его было удобно использовать в веб или мобильных клиентах.
## 2. Область применения (Scope) и бизнес-требования
**Задачи, решаемые проектом:**  Проект предназначен для решения задач онлайн-взаимодействия и коммуникации. С его помощью пользователи смогут поддерживать социальные связи через интернет: находить знакомых, обмениваться сообщениями (в форме постов и комментариев), выражать реакцию на записи друг друга. Платформа централизует хранение профилей и контента, обеспечивая быстрый доступ к данным и удобство обмена информацией. Кроме того, платформа решает задачу безопасного хранения пользовательских данных и их защищенного доступа через токены безопасности (JWT).**Основные бизнес-требования и сценарии использования:**
- *Регистрация нового пользователя:* Неавторизованный посетитель предоставляет необходимые данные (например, имя, адрес электронной почты, пароль) через API. Система создает учетную запись, храня пароли в зашифрованном виде. **Сценарий:**  Пользователь отправляет запрос регистрации -> система проверяет корректность данных и уникальность логина/email -> создает запись пользователя в БД -> возвращает подтверждение успешной регистрации.

- *Авторизация (логин):* Пользователь вводит свои учетные данные (логин/пароль). Система проверяет их и выдает JWT токен, который будет использоваться для последующих запросов. **Сценарий:**  Пользователь отправляет запрос на логин с логином и паролем -> система сверяет хэш пароля с хранимым -> при успехе генерирует JWT токен с информацией о пользователе и сроком действия -> возвращает токен клиенту.

- *Просмотр и редактирование профиля:* Авторизованный пользователь запрашивает свои данные профиля или обновляет их (например, меняет статус, фотографию профиля и т.п.). **Сценарий:**  Клиент запрашивает данные профиля через GET `/api/users/{id}` -> система возвращает информацию (кроме чувствительных данных, таких как пароль). Для редактирования клиент отправляет PUT-запрос с изменениями -> система валидирует JWT (чтобы пользователь мог менять только свой профиль) -> обновляет соответствующие поля в БД.

- *Поиск других пользователей:* Пользователь ищет людей по имени/электронной почте/другим параметрам. **Сценарий:**  Отправляется GET-запрос на `/api/users?search=<query>` -> система выполняет поиск по индексированным полям (например, имени пользователя) -> возвращает список подходящих профилей (ограниченный по количеству, с пагинацией).

- *Добавление в друзья:* Пользователь отправляет запрос на добавление другого пользователя в друзья. **Сценарий:**  Клиент (пользователь A) вызывает POST `/api/users/{A}/friends/{B}` -> система проверяет, что A имеет право отправить запрос (A == аутентифицированный пользователь) и что B существует -> создает "запрос дружбы" (в БД помечается, что пользователь B имеет входящий запрос от A) -> возвращает статус. Пользователь B может затем подтвердить дружбу: PATCH или POST запрос подтверждения -> система обновляет статус связи на "друзья". После подтверждения оба пользователя становятся друзьями друг другу.

- *Публикация поста:* Пользователь создает новый пост (запись) в своей хронике. **Сценарий:**  Авторизованный клиент делает POST `/api/posts` с содержимым поста (JSON с текстом, ссылками на изображения и т.д.) -> система валидирует JWT, извлекает из токена ID пользователя-автора -> сохраняет новый пост в БД, связывая с ID автора, устанавливает время создания -> возвращает данные созданного поста (включая сгенерированный ID, время).

- *Просмотр ленты новостей:* Пользователь просматривает ленту постов от своих друзей. **Сценарий:**  Клиент запрашивает GET `/api/users/{id}/feed` -> система аутентифицирует пользователя (id должно совпадать с токеном или токен имеет право на просмотр) -> система находит всех друзей пользователя {id} -> выбирает последние посты этих друзей из базы, сортирует по времени (с использованием SQL или на уровне сервиса) -> возвращает список постов в формате JSON (с возможностью разбивки на страницы, например, передача параметров `page` и `size`).

- *Лайки и комментарии:* Пользователь ставит "лайк" на пост или пишет комментарий. **Сценарий лайка:**  Клиент отправляет POST `/api/posts/{postId}/like` -> система удостоверяется, что пользователь (из JWT) не лайкал этот пост ранее -> создает запись лайка (связь между пользователем и постом) -> возможно, увеличивает счетчик лайков у поста -> возвращает успех. **Сценарий комментария:**  Клиент POST `/api/posts/{postId}/comments` с текстом комментария -> система проверяет токен -> сохраняет комментарий (связав с постом и автором комментария) -> возвращает данные нового комментария.

- *Уведомления:* (Опционально) Например, когда пользователь получает новый запрос в друзья или его пост прокомментировали, система создает уведомление. Пользователь может запросить свои уведомления: GET `/api/notifications` -> система возвращает список непрочитанных уведомлений. (Реализация уведомлений может быть отложена или упрощена, например, путём периодического опроса со стороны клиента).

- *Администрирование:* (Если входит в скоп проекта) Администраторы могут удалять контент, блокировать пользователей. Это предполагает роль "ADMIN" в системе. **Сценарий:**  Админ делает DELETE запрос на `/api/posts/{postId}` -> система проверяет роль из JWT -> удаляет пост и связанные комментарии/лайки из базы.
  **Ограничения:**  В рамках данного ТЗ реализация **реального времени**  (например, мгновенного обновления ленты или чата) не рассматривается – взаимодействие происходит посредством запросов к API. Мобильные push-уведомления или email-оповещения также вне рамок данного проекта. Фокус – на разработке надежного серверного ядра социальной сети, которое может масштабироваться и быть расширено при необходимости.
## 3. Технологический стек
**Java Core + Spring:**  Проект будет реализован на языке **Java**  (версия 17, LTS, либо актуальная стабильная версия) с использованием экосистемы **Spring** . Выбор обусловлен следующими причинами:
- Java – производительный, масштабируемый язык, богатый экосистемой библиотек и фреймворков, хорошо подходящий для серверных приложений. Позволяет использовать ООП-модели для сущностей социальной сети.

- **Spring Boot**  ускоряет разработку, предоставляя готовую инфраструктуру для создания standalone веб-приложений. Он упрощает настройку за счет автоконфигурации.

- **Spring MVC/Web**  (в составе Boot) облегчит создание REST API контроллеров и маршрутизацию HTTP-запросов. Аннотации (@RestController, @RequestMapping и др.) позволяют быстро описать API.

- **Spring Data JPA**  (Hibernate) предоставляет ORM для удобной работы с базой данных на уровне Java-объектов. Это ускоряет разработку доступа к данным (репозитории, CRUD операции) и уменьшает количество шаблонного кода SQL.

- **Spring Security**  обеспечит безопасность приложения: аутентификацию и авторизацию. В связке с JWT (JSON Web Token) Spring Security позволит легко защитить REST API эндпоинты, требуя токены от клиентов и проверяя их.

- **Spring Cloud (Netflix OSS)**  может использоваться для реализации API Gateway и других паттернов микросервисов (например, для регистрации сервисов, circuit breaker). В частности, **Spring Cloud Gateway**  выбран для реализации API Gateway, так как он интегрируется со Spring Security и поддерживает JWT.
  **Hibernate / JPA:**  используется как реализация JPA для взаимодействия с **реляционной базой данных (PostgreSQL)** . Hibernate берет на себя преобразование Java-сущностей (классов Entity) в таблицы и SQL-запросы, что ускоряет разработку и обеспечивает поддержку транзакционности. Выбор JPA/Hibernate также облегчает переносимость кода между разными СУБД при необходимости.**SQL и база данных (PostgreSQL):**  В качестве СУБД выбрана **PostgreSQL**  по следующим причинам:
- PostgreSQL – открытая и мощная реляционная СУБД, которая хорошо масштабируется и поддерживает сложные запросы, транзакции, хранимые процедуры.

- Социальная сеть генерирует связные данные (пользователи, связи, посты, лайки и т.д.), которые удобно хранить в реляционной модели с четкими отношениями (связи один-ко-многим, многие-ко-многим).

- Поддерживается Hibernate (через JDBC драйвер), имеется опыт использования в продакшене.

- Требования к согласованности данных (например, нельзя допустить "полудобавленного" пользователя или поста) легко обеспечиваются транзакциями ACID, которые предоставляет PostgreSQL.

- Будет спроектирована структура базы данных с учетом индексов на часто запрашиваемые поля (например, индекс по полю username для быстрого поиска пользователей, индексы по внешним ключам для ускорения джоинов). Используются **внешние ключи**  для обеспечения ссылочной целостности (например, пост всегда ссылается на существующего пользователя-автора).

- Предусмотрено использование транзакций при групповых операциях (например, добавление дружбы — две связанные записи — будет обернуто в транзакцию).
  **REST API:**  Для взаимодействия с клиентами (и между микросервисами) используется архитектурный стиль **REST**  поверх HTTP. Формат передаваемых данных – **JSON**  (JavaScript Object Notation) как легковесный и широко поддерживаемый формат. Все сервисы предоставляют четко определенные REST-эндпоинты с понятными URL, использованием соответствующих HTTP методов (GET для получения данных, POST для создания, PUT/PATCH для обновления, DELETE для удаления). Каждый запрос/ответ имеет определенную JSON-структуру (описана в спецификации API ниже). Для документирования API будет применен **OpenAPI (Swagger)** : это облегчит поддержку и тестирование, позволяя генерировать интерактивную документацию.**Docker (контейнеризация и деплой):**  Для упрощения развертывания и поддержки консистентной среды исполения, проект использует **Docker** :
- Каждая микросервисная компонента (см. раздел *Архитектура проекта*) упакована в отдельный Docker-образ. Образы основаны на официальном **OpenJDK**  runtime для Java.

- Использование Docker гарантирует, что приложение будет работать одинаково в средах разработки, тестирования и продакшена, устраняя проблемы "работает на моей машине".

- Контейнеризация упрощает масштабирование: можно запускать несколько контейнеров одного сервиса за балансировщиком нагрузки.

- **Docker Compose**  будет использоваться для локального запуска всего набора сервисов (микросервисы + база данных + возможно другие компоненты) одной командой. В Compose файле описаны все сервисы и их связь (например, сервисы зависят от контейнера с БД).

- В продакшене контейнеры могут быть развёрнуты на одном или нескольких узлах. Возможно использование оркестрации (Kubernetes) в будущем, но в рамках данного ТЗ предполагается Docker Compose или аналог для демонстрации работы системы.
  **Тестирование (JUnit, Mockito):**
- Для модульного тестирования логики используются **JUnit 5**  (Jupiter) фреймворк, а для имитации зависимостей – **Mockito** .

- Тесты позволят проверять корректность работы сервисов (например, правильность бизнес-логики методов) в изоляции.

- Spring Boot также предоставляет удобства для тестирования, например аннотации @SpringBootTest, @WebMvcTest, а также встроенные средства для поднятия контекста и использования in-memory баз (H2) для интеграционного тестирования JPA.

- Покрытие кода тестами – один из требований качества, поэтому на критичные компоненты (сервисы, утилиты, безопасность) будут написаны тест-кейсы.
  **Spring Security + JWT:**
- Безопасность – ключевой аспект. Используется **Spring Security**  для реализации аутентификации и авторизации, а также **JWT (JSON Web Tokens)**  для безсессионной аутентификации.

- При логине генерируется JWT токен (подписанный HS256 или RS256 ключом). Токен включает в себя идентификатор пользователя и, возможно, роль (например, ROLE_USER, ROLE_ADMIN).

- Токен отправляется клиенту, а клиент прикрепляет его к каждому последующему запросу в заголовке `Authorization: Bearer <JWT>`.

- Spring Security на стороне сервера настроен на проверку JWT: для этого используется фильтр, который перехватывает запросы, валидирует подпись и срок действия токена, извлекает информацию о пользователе.

- Также Spring Security обеспечивает **role-based**  ограничение доступа к определенным эндпоинтам (например, админ-эндпоинты закрыты от обычных пользователей).

- **API Gateway**  (шлюз) тоже интегрируется с Spring Security, выступая первой линией проверки JWT для всех входящих запросов.
  **Микросервисная архитектура:**
- Система будет разделена на несколько **микросервисов**  (см. след. раздел), каждый из которых отвечает за определенную область данных или функциональности (Auth, Пользователи, Посты и т.д.).

- Микросервисы взаимодействуют через легковесные механизмы – в основном REST API друг друга (с использованием внутренних защищенных вызовов).

- **API Gateway**  служит единым входом в систему, получая запросы от клиентов и перенаправляя их в нужный микросервис. Это позволяет скрыть внутреннюю структуру сервисов от внешних клиентов и централизовать кросс-сервисные проблемы (аутентификация, агрегирование данных, CORS).

- Для конфигурации и консистентности версий между микросервисами используется **Git**  (Gitflow рабочий процесс, см. ниже) и возможны инструменты Spring Cloud Config (в перспективе, для централизованной конфигурации) – но базово настройки для каждого сервиса хранятся в его application.properties/yaml или через переменные окружения (что поддерживается Docker Compose).

- Микросервисный подход обеспечивает гибкость масштабирования: при увеличении нагрузки на конкретный сервис (например, сервис постов), мы можем масштабировать именно его, не трогая остальные. Также облегчается поддержка – небольшие кодовые базы, сфокусированные на одной задаче.
  **Система контроля версий (Git):**
- Код проекта хранится в репозитории **Git** . Для командной работы принят workflow **Gitflow** : отдельные ветки для разработки новых функций, интеграционная ветка develop, стабильная главная ветка main (master) для релизов и релизные/горячие фикс-ветки при необходимости.

- Такой подход позволит параллельно нескольким разработчикам вести работу и интегрировать изменения поэтапно, с код-ревью через Pull Request.

- Каждое существенное изменение сопровождается информативным коммит-сообщением, соответствующим стандартам (например, указание типа изменения: feature, fix, docs и краткое описание).

- Репозиторий также хранит документацию (в README.md, Wiki) и, возможно, спецификации API (в Swagger/OpenAPI формате JSON/YAML).

## 4. Архитектура проекта
**Общая структура:**  Проект построен по **микросервисной архитектуре** . Предполагается разделение на следующие основные сервисы:
- **API Gateway**  – Шлюз API, единая точка входа для всех клиентов. Он принимает все внешние HTTP-запросы и на основе URL/маршрута и правил безопасности перенаправляет их к нужному внутреннему сервису. Gateway осуществляет проверку JWT (аутентификацию) для защищенных маршрутов, а также может выполнять агрегирование ответов от нескольких сервисов (если требуется) или простую маршрутизацию.

- **Auth Service**  – Сервис аутентификации и авторизации. Отвечает за вход пользователя в систему: проверяет учетные данные и выдает JWT. В перспективе может отвечать за refresh-токены, logout (инвалидация токенов, хотя JWT по природе самодостаточный и хранилища не требует) и управление доступом. Может работать совместно с пользовательским сервисом (чтобы получать/создавать учетные данные).

- **User Service**  – Сервис управления пользователями. Ведает всеми операциями, связанными с профилями пользователей: регистрация нового пользователя, получение и изменение данных профиля, управление дружбой (отправка запросов, принятие, список друзей). Хранит информацию о пользователях и их социальном графе (друзьях).

- **Post Service**  – Сервис управления постами (контентом). Обрабатывает создание, редактирование, удаление постов, выдачу ленты новостей. Также включает функциональность взаимодействия с постами: комментарии и лайки (возможно как подсервисы или внутри этого же сервиса для упрощения). Хранит все публикации пользователей, их комментарии, и связи "пост-лайк" в своей базе.

- **Notification Service**  – (опционально) Сервис уведомлений. Отвечает за формирование и доставку уведомлений пользователям о различных событиях (новый друг, новая реакция на пост и др.). Может реализовываться через асинхронные механизмы (например, помещать события в очередь сообщений Kafka/RabbitMQ, а затем отправлять уведомления).

- **Дополнительные сервисы**  – при необходимости архитектура может быть расширена отдельными микросервисами: например, **Comment Service**  или **Like Service**  (если выделять из Post Service), **Search Service**  (для полнотекстового поиска по постам/профилям, возможно на основе ElasticSearch, но это вне рамок базового функционала), **Admin Service**  (для администрирования, или эти функции могут быть включены в User/Post сервисы с проверкой роли).
  **API Gateway и маршрутизация:**  API Gateway (возможно реализованный на Spring Cloud Gateway) содержит маршруты, которые соответствуют эндпоинтам микросервисов. Например:
- Запросы, начинающиеся с `/api/auth/**` направляются на Auth Service.

- Запросы к `/api/users/**` идут на User Service.

- Запросы к `/api/posts/**` – на Post Service.

- (Если Notification Service имеет внешние эндпоинты, например `/api/notifications/**` – на Notification Service).
  Gateway также интегрирован со **Spring Security** : перед перенаправлением запроса он проверяет наличие и валидность JWT токена, удостоверяется, что у пользователя есть нужные права для запрошенного ресурса. Например, запрос на `/api/admin/**` может требовать роль ADMIN в токене – Gateway проверит это и либо пропустит, либо вернет 403 Forbidden без дерганья внутреннего сервиса.
  **Взаимодействие микросервисов:**  Общая схема предполагает, что большинство операций выполняются внутри одного сервиса. Однако некоторые сценарии требуют межсервисного взаимодействия:
- Пример: при логине Auth Service должен проверить учетные данные пользователя. Возможны два подхода:
    1. Auth Service имеет доступ к базе данных пользователей (только к таблице учетных данных) напрямую.

    2. Auth Service обращается к User Service по внутреннему API, запрашивая пользователя по логину и получая хэш пароля для проверки.
       Выбирается второй подход, чтобы соблюсти **принцип единственной ответственности**  – User Service владеет данными пользователей. Auth Service шлет внутренний запрос (например, REST или gRPC) к User Service: "дай пользователя с логином X". User Service возвращает данные, Auth Service сверяет пароль и генерирует JWT. Этот подход несколько увеличивает задержку на логин, но разделяет обязанности четко.

- Другой пример: Post Service при формировании ленты получает список друзей пользователя. Здесь Post Service может запросить у User Service список идентификаторов друзей. Затем Post Service делает запрос к своей базе по этим ID. **Альтернатива:**  поддерживать в Post Service кэш или реплицированные данные, но в первой версии проще сделать межсервисный запрос.

- Если Notification Service внедрен, он может получать события из других сервисов. Например, после того как Post Service сохраняет новый комментарий, он может отправить сообщение (через REST или сообщение в брокер) Notification-сервису: "для пользователя X событие: ваш пост прокомментирован". Notification Service тогда сохраняет уведомление и/или рассылает его.
  **Схема микросервисов:**  (логическое описание без рисунка)
- **Client (Web/Mobile)**  → **API Gateway**  → маршруты:
    - `/api/auth/*` → **Auth Service**

    - `/api/users/*` → **User Service**

    - `/api/posts/*` → **Post Service**

    - `/api/notifications/*` → **Notification Service**  (если реализован)

- **Внутренние связи:**
    - Auth Service ↔ User Service (взаимодействие при регистрации и аутентификации)

    - Post Service → User Service (запросы списка друзей, профилей при необходимости)

    - (Post Service → Notification Service, User Service → Notification Service для событий уведомлений)

    - Все сервисы могут иметь доступ к общей инфраструктуре (например, к очереди сообщений, к сервису конфигурации, к мониторингу).
      **Примечание:**  На первом этапе можно не внедрять брокеры сообщений или динамическое обнаружение сервисов (Service Registry). Маршруты Gateway настроены статически, URL внутренних сервисов фиксированы (например, `USER_SERVICE_HOST` и т.д. заданы в переменных окружения Docker). Это упростит реализацию. В дальнейшем возможна интеграция **Eureka**  или **Consul**  для автоматического обнаружения и балансировки между экземплярами микросервисов.
## 5. Описание модулей/микросервисов

Ниже описана функциональность каждого микросервиса (модуля) и формат данных, с которыми он работает:
**1. Auth Service (Сервис аутентификации):**
- **Назначение:**  Управление входом в систему и выдачей токенов. Необходим для безопасности – отделяет процесс проверки логина/пароля и генерации JWT от остальных сервисов.

- **Основные функции:**
    - **Login:**  Проверка предоставленного логина и пароля пользователя. Если они корректны – генерация JWT токена и возврат его клиенту. JWT содержит идентификатор пользователя и роли, подписан секретным ключом (HS256) или парой ключей (RS256).

    - **Token Refresh (опционально):**  Выпуск нового JWT по истечении старого с использованием refresh-токена (требует реализации хранения/проверки refresh-токенов, возможно не реализуется в первой версии).

    - **Logout (опционально):**  В случае JWT, логаут на сервере обычно не нужен (клиент просто забывает токен). Однако может вестись "чёрный список" отозванных токенов (например, если нужно принудительно завершить сессии).

- **Взаимодействие с другими сервисами:**
    - При логине Auth Service должен получить данные пользователя. Он будет обращаться в User Service по внутреннему API: запрашивать пользователя по имени или email.

    - Если пользователь не найден или пароль не совпадает – возвращается ошибка.

    - При успешном логине – Auth Service создает JWT самостоятельно (внутри себя, используя библиотеку JWT).

- **Формат данных:**
    - **Запрос логина**  ожидает JSON с полями `{ "username": "...", "password": "..." }`.

    - **Ответ при успешном логине** : JSON с токеном, например `{ "token": "<JWT>", "expires": "<ISO8601 datetime>" }`. Токен – строка (типично ~от eyJhbGciOi...).

    - **Ответ при ошибке аутентификации** : код 401 Unauthorized и сообщение об ошибке в JSON `{ "error": "Invalid credentials" }`.

    - Auth Service сам по себе не хранит больших данных, кроме, возможно, ключей для подписи токенов (или секретной фразы). Пользовательские данные хранятся в User Service.
      **2. User Service (Сервис пользователей):**
- **Назначение:**  Управление учетными записями пользователей и их социальными связями.

- **Основные функции:**
    - **Регистрация пользователя:**  Создание новой учетной записи. User Service получает данные нового пользователя (имя, email, пароль и т.д.), валидирует их (уникальность email/логина), хэширует пароль (например, BCrypt) и сохраняет запись в БД. Возвращает созданного пользователя (или сокращенные данные) при успехе.

    - **Получение профиля:**  Предоставляет информацию профиля по запросу. Может различать собственный профиль (с полной информацией) и чужой профиль (с общедоступной информацией, без личных данных).

    - **Обновление профиля:**  Изменение данных – например, изменение статуса, загрузка аватара (в бэкенде – сохранение ссылки на аватар, сам файл мог бы храниться во внешнем объектном хранилище).

    - **Управление дружбой:**
        - Отправка запроса дружбы: сохранение записи "в ожидании" между пользователями (заявка).

        - Принятие/отклонение заявки: изменение статуса существующей записи или создание взаимных записей дружбы.

        - Удаление из друзей: удаляет связь между двумя пользователями.

        - Получение списка друзей, входящих заявок, исходящих заявок.

    - **Поиск пользователей:**  Поиск по имени, email или другим атрибутам (с использованием SQL `LIKE` или полнотекстового поиска при увеличении требований).

- **Взаимодействие:**
    - User Service получает запросы от Gateway, проверяет JWT (Spring Security) на валидность и извлекает оттуда userId для операций, связанных с текущим пользователем.

    - При успешной регистрации нового пользователя может уведомлять Auth Service (в базовой версии не обязательно) или просто позволяет Auth Service сразу использовать новые данные.

    - При запросах дружбы, User Service может уведомлять Notification Service о новых заявках (если уведомления реализованы).

    - Также, если Post Service запрашивает информацию о пользователях (имя, аватар) для отображения в ленте, User Service предоставляет необходимый API (например, batch-запрос: получить информацию о нескольких пользователях по их ID).

- **Хранение данных:**  PostgreSQL таблица пользователей и таблица связей (дружбы). Подробно структура – в разделе БД.

- **Формат данных:**  Все обмены – JSON.
    - Данные пользователя в ответах: например, `{ "id": 123, "username": "john_doe", "name": "John Doe", "bio": "Hello!", "avatarUrl": "/media/avatars/123.jpg" }`. (Без поля пароля, конечно.)

    - Запрос на обновление профиля может принимать частичный JSON с изменяемыми полями (имя, био).

    - Дружба: заявка может быть представлена как объект `{ "id": 555, "fromUser": 123, "toUser": 456, "status": "PENDING" }` или просто имплицитно через эндпоинт.
      **3. Post Service (Сервис постов):**
- **Назначение:**  Управление социальным контентом – постами, лентой, а также реакциями (лайками) и комментариями к постам.

- **Основные функции:**
    - **Создание поста:**  Пользователь публикует новый пост. Сервис сохраняет пост в своей базе, включая содержимое, автора (ID пользователя), время создания. Возвращает созданный пост.

    - **Получение поста:**  По запросу возвращает содержимое конкретного поста (текст, автор, время, количество лайков, последние комментарии или число комментариев).

    - **Удаление/редактирование поста:**  Автор поста может отредактировать содержимое (например, исправить текст) или удалить пост. При удалении также удаляются связанные лайки и комментарии (в рамках данного сервиса).

    - **Лента новостей:**  Отдает список постов друзей. Реализуется запросом: сервис получает от User Service список друзей запрашивающего пользователя, затем делает выборку постов этих друзей, сортирует по дате. Добавляется пагинация (например, по 20 постов на страницу, с параметрами page, size).

    - **Лайки:**
        - Добавление лайка к посту: создает запись (userId, postId) в таблице лайков. Можно возвращать обновленный счетчик.

        - Удаление лайка (повторный запрос может снимать лайк).

        - Получение всех лайков поста (список пользователей, пролайкавших пост) – возможно не критично для UI, но API может предоставить.

    - **Комментарии:**
        - Добавление комментария к посту: сохраняет комментарий с указанием автора (userId), поста (postId), текста, времени.

        - Удаление или редактирование комментария – автор комментария или автор поста (для модерации) может удалить.

        - Получение комментариев поста (с пагинацией, если их много).

- **Взаимодействие:**
    - Post Service при формировании ленты обращается к User Service (список друзей) или может требовать от клиента передавать список (плохой вариант, лучше сервис сам).

    - При отображении поста, если нужны детали автора или комментаторов, Post Service может либо хранить часть информации (например, username автора в посте для быстрой отдачи), либо запрашивать User Service при необходимости. В первом приближении, Post Service хранит только userId, а клиент при необходимости может допрашивать User Service для получения имен. (В дальнейшем можно оптимизировать денормализацией – хранить username копией.)

    - Post Service также может взаимодействовать с Notification Service: например, при новом комментарии – уведомить автора поста.

- **Хранение данных:**  Своя PostgreSQL база (или схема) с таблицами постов, комментариев, лайков. Структура – см. раздел БД.

- **Формат данных:**  JSON:
    - Пример объекта поста в ответе:

```json
{
  "id": 101,
  "authorId": 123,
  "content": "Это мой первый пост!",
  "createdAt": "2025-02-22T10:15:30",
  "likesCount": 5,
  "commentsCount": 2
}
```
(При необходимости можно возвращать вложенный объект автора, но тогда Post Service должен знать детали или клиент должен запрашивать отдельно).

- Для создания/редактирования поста клиент отправляет JSON с требуемыми полями, например `{ "content": "Новый текст поста" }` на соответствующий эндпоинт.

- Комментарий может быть представлен как `{ "id": 301, "postId": 101, "authorId": 456, "text": "Привет!", "createdAt": "2025-02-22T11:00:00" }`.

- Запрос лайка не требует тела – только идентификация пользователя через JWT.
  **4. Notification Service (Сервис уведомлений, опционально):**
- **Назначение:**  Уведомление пользователей о событиях (необязательно для первого релиза, но учитывается в архитектуре).

- **Основные функции:**  Принимать события из других сервисов (новый пост друга, лайк, комментарий, запрос дружбы) и создавать записи уведомлений. По запросу клиента – возвращать список уведомлений.

- **Реализация:**  Может слушать сообщения из брокера (Kafka/RabbitMQ) или предоставлять REST API для вызова другими сервисами. Например, Post Service может вызывать `POST /internal/notify` на Notification Service.

- **Хранение:**  Таблица уведомлений (notification) с полями: id, userId (кому), type (тип события), reference (ссылка на объект события: например, пост или пользователь), текст или шаблон сообщения, флаг прочитано/непрочитано, время.

- **Формат данных:**  JSON, например уведомление: `{ "id": 900, "userId": 123, "type": "FRIEND_REQUEST", "message": "Пользователь Ivan отправил вам запрос дружбы", "read": false, "createdAt": "2025-02-22T12:00:00" }`.
  **5. API Gateway:**
- **Назначение:**  Центральный маршрутизатор запросов от клиентов к микросервисам. Обеспечивает единый домен/адрес для внешнего обращения и скрывает внутренние адреса сервисов.

- **Функции:**
    - **Маршрутизация:**  Перенаправление запросов на основе правил (шаблонов URL) к целевому сервису. Например, реализовано с помощью конфигурации Spring Cloud Gateway: routes YAML, либо Java-конфигурации RouteLocator.

    - **Аутентификация и авторизация:**  Внедрена фильтрация запросов – Gateway проверяет JWT токен (если требуется для данного URL). Это делается глобально, чтобы не дублировать логику проверки в каждом сервисе. Однако **вопрос безопасности** : можно настроить так, что Gateway валидирует JWT и проксирует запрос дальше, добавляя, например, заголовок с userId или просто передавая тот же JWT. Внутренние сервисы могут доверять, что если запрос прошел через Gateway, он уже авторизован. Тем не менее, для дополнительной безопасности обычно **каждый сервис**  также самостоятельно проверяет JWT (особенно если можно миновать Gateway; но при правильной инфраструктуре миновать Gateway извне нельзя).

    - **SSL/TLS:**  Gateway может терминировать SSL-соединения (HTTPS) на себе, обеспечивая шифрование трафика с клиентами. Внутренние связи микросервисов могут быть в доверенной сети и идти по HTTP.

    - **CORS и ограничение доступа:**  Gateway настроен отдавать корректные CORS заголовки для фронтенд-приложений (разрешая нужные источники, методы). А также может ограничивать доступ к определенным ресурсам (например, IP-фильтрация, rate limiting в целях защиты от DDoS).

    - **Логирование и трейсинг:**  Gateway будет логировать входящие запросы, исходящие к сервисам, время обработки – для целей мониторинга. Можно внедрить корреляционные ID (например, traceId) чтобы отслеживать запрос через все сервисы.

- **Формат данных:**  Gateway в идеале прозрачен – он просто пересылает JSON запросы и ответы. Никакой трансформации данных (кроме агрегаций, если бы требовалось) не происходит. То есть, формат запросов/ответов определяется микросервисами; Gateway лишь добавляет заголовки (например, `X-User-ID` после аутентификации) или убирает внутренние заголовки.
  **Формат обмена данными между сервисами:**
- Используются синхронные REST вызовы через HTTP внутри внутренней сети (например, User Service поднимается на `http://user-service:8081/`, Post Service `http://post-service:8082/` и Gateway знает эти адреса). Формат данных тоже JSON. Для безопасности внутренние запросы могут содержать специальный сервисный токен или заголовок API-ключа, хотя если они изолированы в докер-сети, можно считать их доверительными.

- Возможны асинхронные коммуникации: например, Notification Service может подписаться на события. Если внедряется брокер сообщений (не в первой итерации), формат сообщений – JSON (схема оговаривается, например, событие "NEW_COMMENT" содержит postId, authorId, текст и т.д.).

Таким образом, каждый модуль чётко отвечает за свой участок функционала, что облегчает сопровождение и масштабирование. Ниже приведены спецификации API и структура базы данных, детализирующие взаимодействие и хранение.

## 6. RestAPI-спецификация
В этом разделе описываются основные REST API эндпоинты для каждого сервиса: URL, методы, параметры, структура запросов и ответов, а также коды ответов сервера. Формат данных – JSON. Все URL указаны с учетом маршрутизации через API Gateway (т.е. внешние для клиента). Предполагается префикс `/api` для всех маршрутов.**6.1 Auth Service API:**
- **POST**  `/api/auth/register` – *Регистрация нового пользователя.*
  **Описание:**  Создает новую учетную запись пользователя.
  **Тело запроса:**  JSON с обязательными полями, например:

```json
{
  "username": "john_doe",
  "email": "john@example.com",
  "password": "securePassword"
}
```
**Ответ:**  При успешной регистрации – код 201 Created. Тело ответа может содержать профиль нового пользователя (либо минимальную информацию):

```json
{
  "id": 123,
  "username": "john_doe",
  "email": "john@example.com"
}
```
Пароль не возвращается. Также возможен автоматический вход – например, сразу вернуть JWT токен (опционально).
**Коды ответов:**  201 (Created), 400 (Bad Request, если данные не валидны, например, короткий пароль или занятый username/email), 409 (Conflict, если пользователь с таким именем/почтой уже существует).

- **POST**  `/api/auth/login` – *Аутентификация (вход).*
  **Описание:**  Проверяет логин и пароль пользователя, выдаёт JWT при успешной аутентификации.
  **Тело запроса:**  JSON с полями для входа (либо `username`+`password`, либо `email`+`password`, в зависимости от того, как пользователь идентифицируется – допустим, логин):

```json
{
  "username": "john_doe",
  "password": "securePassword"
}
```
**Ответ:**  При успешной проверке возвращается JWT токен:

```json
{
  "token": "<JWT字符串>",
  "tokenType": "Bearer",
  "expiresIn": 3600
}
```
где `token` – сам JWT, `tokenType` указывает тип (для клиента, обычно Bearer), `expiresIn` – время жизни токена в секундах.
Токен также может передаваться через заголовки ответа (`Authorization: Bearer <token>`).
**Коды ответов:**  200 (OK – успешный вход), 401 (Unauthorized – неверные учетные данные), 400 (если запрос неверен по формату).
**Примечание:**  После получения токена, клиент должен использовать его в заголовке `Authorization` для всех защищенных запросов.

- *(Опционально)* **POST**  `/api/auth/refresh` – *Обновление JWT токена.*
  **Описание:**  Выдает новый JWT по действующему refresh-токену. Требует отправить refresh-токен (выданный при логине) и возвращает новый access-token.
  **Тело запроса:**  `{ "refreshToken": "<refresh_jwt>" }`.
  **Ответ:**  `{ "token": "<new_access_jwt>", "expiresIn": 3600 }`.
  **Коды:**  200 (OK), 401 (если refresh недействителен).
  **6.2 User Service API:**
- **GET**  `/api/users/{id}` – *Получить профиль пользователя.*
  **Описание:**  Возвращает информацию профиля пользователя с идентификатором `{id}`.
  **Требует авторизации:**  Доступно для авторизованных пользователей. Если `{id}` совпадает с ID текущего пользователя – можно возвращать полную инфу, иначе – ограниченную (нет email, приватных полей).
  **Ответ:**  200 OK с телом:

```json
{
  "id": 123,
  "username": "john_doe",
  "name": "John Doe",
  "bio": "Hello, I'm John!",
  "avatarUrl": "/media/avatar123.jpg",
  "friendsCount": 50,
  "postsCount": 10
}
```
**Коды ошибок:**  404 (Not Found – если пользователь не найден), 403 (Forbidden – если доступ запрещен, например, запрашивают чужие приватные данные).

- **PUT**  `/api/users/{id}` – *Обновить профиль пользователя.*
  **Описание:**  Изменяет данные профиля пользователя `{id}`. Пользователь должен быть авторизован и иметь право редактировать этот профиль (или админ).
  **Тело запроса:**  JSON с полями, которые нужно изменить. Например:

```json
{
  "name": "Johnathan Doe",
  "bio": "Обновлённое описание профиля"
}
```
(email и username обычно не позволяют менять, либо требуют отдельной процедуры; здесь – по усмотрению.)
**Ответ:**  200 OK с обновленными данными профиля (или 204 No Content без тела).
**Коды ответов:**  200 (OK), 400 (невалидные данные), 401 (не авторизован), 403 (нет прав – пытается изменить чужой профиль), 404 (пользователь не найден).

- **GET**  `/api/users?search={query}` – *Поиск пользователей.*
  **Описание:**  Ищет пользователей по имени или логину, содержащим подстроку `{query}`. Доступно авторизованным.
  **Параметры:**  `query` – строка поиска; пагинация: `page`, `size`.
  **Ответ:**  200 OK, тело – список пользователей (может быть сокращенный формат):

```json
{
  "results": [
    { "id": 123, "username": "john_doe", "name": "John Doe", "avatarUrl": "/avatar123.jpg" },
    { "id": 124, "username": "jane", "name": "Jane Smith", "avatarUrl": "/avatar124.jpg" }
  ],
  "page": 1,
  "size": 20,
  "total": 2
}
```
**Коды ошибок:**  400 (если параметр отсутствует или некорректен).

- **POST**  `/api/users/{id}/friends/{friendId}` – *Отправить запрос на добавление в друзья.*
  **Описание:**  Аутентифицированный пользователь `{id}` отправляет запрос пользователю `{friendId}`. По сути создается заявка в друзья.
  **Права:**  `{id}` должно совпадать с ID в JWT (пользователь посылает заявку от своего имени).
  **Тело запроса:**  (не требуется, вся информация в URL и токене).
  **Ответ:**  200 OK или 201 Created, тело может содержать объект дружбы или подтверждение:

```json
{ "status": "REQUEST_SENT" }
```
**Коды ответов:**  201 (если создана новая запись заявки), 400 (если уже отправлен запрос или попытка добавить самого себя), 401 (не авторизован), 404 (если пользователь friendId не найден).

- **GET**  `/api/users/{id}/friends` – *Получить список друзей пользователя.*
  **Описание:**  Возвращает список пользователей, являющихся друзьями пользователя `{id}`.
  **Ответ:**  200 OK, тело:

```json
{
  "friends": [
     { "id": 124, "username": "jane", "name": "Jane Smith", "avatarUrl": "/avatar124.jpg" },
     ...
  ],
  "count": 50
}
```
**Замечание:**  Если `{id}` совпадает с текущим пользователем – вернет весь список друзей. Если нет и профиль приватный – можно вернуть ошибку 403 или пустой список/только общих друзей.

- **POST**  `/api/users/{id}/friends/{friendId}/accept` – *Принять запрос в друзья.*
  **Описание:**  Пользователь `{id}` принимает заявку от пользователя `{friendId}`. Сервис обновляет связь, теперь пользователи друзья.
  **Ответ:**  200 OK `{ "status": "FRIENDS" }` (или возвращает обновленную запись дружбы).
  **DELETE**  `/api/users/{id}/friends/{friendId}` – *Удалить из друзей/отклонить заявку.* – аналогично, меняет статус или удаляет связь, возвращает 200 OK.

- *(Дополнительно)* **GET**  `/api/users/{id}/requests` – получить список входящих заявок в друзья для пользователя.
  **6.3 Post Service API:**
- **POST**  `/api/posts` – *Создать новый пост.*
  **Описание:**  Создает пост от имени текущего аутентифицированного пользователя.
  **Тело запроса:**  JSON с содержимым поста:

```json
{
  "content": "Текст поста...",
  "imageUrl": "http://.../image.png"  (опционально, если есть изображение)
}
```
**Ответ:**  201 Created, тело – созданный пост:

```json
{
  "id": 101,
  "authorId": 123,
  "content": "Текст поста...",
  "imageUrl": "http://.../image.png",
  "createdAt": "2025-02-22T10:15:30",
  "likesCount": 0,
  "commentsCount": 0
}
```
**Коды ошибок:**  400 (невалидные данные, например, пустой контент), 401 (не авторизован).

- **GET**  `/api/posts/{postId}` – *Получить пост по ID.*
  **Описание:**  Возвращает содержимое поста с идентификатором `{postId}`.
  **Ответ:**  200 OK, тело аналогично объекту поста выше, дополнительно можно включить массив комментариев или первых N комментариев:

```json
{
  "id": 101,
  "authorId": 123,
  "content": "Текст поста...",
  "createdAt": "2025-02-22T10:15:30",
  "likesCount": 5,
  "commentsCount": 2,
  "comments": [
     { "id": 301, "authorId": 456, "text": "Комментарий", "createdAt": "2025-02-22T11:00:00" },
     ...
  ]
}
```
**Коды ошибок:**  404 (если пост не найден или удален), 403 (если пост принадлежит приватной группе или пользователь не имеет прав просмотра – но в нашей модели все посты друзей видимы, а посты не друзей, возможно, недоступны -> в дальнейшем можно разграничить видимость).

- **DELETE**  `/api/posts/{postId}` – *Удалить пост.*
  **Описание:**  Удаляет пост `{postId}`. Доступно автору поста или администратору.
  **Ответ:**  200 OK (или 204 No Content) при успешном удалении.
  **Коды ошибок:**  404 (не найден), 403 (нет прав – если не автор и не админ), 401 (не авторизован).

- **GET**  `/api/users/{id}/feed` – *Получить ленту новостей пользователя.*
  **Описание:**  Возвращает список последних постов друзей пользователя `{id}` (включая, возможно, его собственные посты или нет – скорее, отдельно для личной стены будет другой запрос).
  **Параметры:**  пагинация `page`, `size` (например, 20 постов на страницу).
  **Ответ:**  200 OK, тело – массив постов (отсортированных по дате, свежие сверху). Например:

```json
{
  "posts": [
    {
      "id": 110,
      "authorId": 124,
      "content": "Пост друга",
      "createdAt": "2025-02-22T09:00:00",
      "likesCount": 3,
      "commentsCount": 1
    },
    {
      "id": 101,
      "authorId": 123,
      "content": "Текст поста...",
      "createdAt": "2025-02-22T10:15:30",
      "likesCount": 5,
      "commentsCount": 2
    }
  ],
  "page": 1,
  "size": 20,
  "hasMore": false
}
```
**Коды ошибок:**  401 (если токен отсутствует/неверен), 403 (если пытается запросить чужую ленту, но чужая лента, вероятно, недоступна – обычно каждый просматривает только свою ленту).

- **POST**  `/api/posts/{postId}/like` – *Поставить лайк посту.*
  **Описание:**  Отметить пост как "нравится" от имени текущего пользователя.
  **Ответ:**  200 OK, тело может содержать новый счетчик лайков `{ "likesCount": 6 }` или статус.
  **Действие:**  Внутри сервис создаст запись лайка. Если лайк уже был – можно вернуть ошибку 409 (Conflict) или тихо игнорировать второй лайк.
  **Коды:**  200 (OK, в т.ч. если лайк уже существовал и ничего не меняется), 404 (если пост не найден).

- **DELETE**  `/api/posts/{postId}/like` – *Убрать лайк с поста.* (опционально, либо повторный вызов POST снимает лайк)
  **Описание:**  Удаляет отметку "нравится" текущего пользователя с поста. Возвращает новый счетчик или 200 без тела.
  **Коды:**  200, 404 (если лайка не было или пост не найден).

- **GET**  `/api/posts/{postId}/likes` – *Получить лайки поста.*
  **Описание:**  Возвращает список пользователей, лайкнувших пост. (Может использоваться для отображения "N likes" и списков).
  **Ответ:**  200 OK, например: `{ "likes": [ { "userId": 123, "username": "john_doe" }, ... ] }`. (Возможно, ограничение по количеству или пагинация).

- **POST**  `/api/posts/{postId}/comments` – *Добавить комментарий к посту.*
  **Описание:**  Создает новый комментарий к посту `{postId}` от текущего пользователя.
  **Тело запроса:**  JSON с текстом комментария, напр.: `{ "text": "Отличный пост!" }`.
  **Ответ:**  201 Created, тело – созданный комментарий:

```json
{
  "id": 310,
  "postId": 101,
  "authorId": 123,
  "text": "Отличный пост!",
  "createdAt": "2025-02-22T12:00:00"
}
```
**Коды ошибок:**  400 (пустой текст), 404 (пост не найден), 401 (не авторизован).

- **GET**  `/api/posts/{postId}/comments` – *Получить комментарии поста.*
  **Описание:**  Возвращает список комментариев для поста, по умолчанию отсортированных по времени (возможна пагинация).
  **Ответ:**  200 OK, тело, например:

```json
{
  "comments": [
    { "id": 301, "postId": 101, "authorId": 456, "text": "Комментарий", "createdAt": "2025-02-22T11:00:00" },
    { "id": 310, "postId": 101, "authorId": 123, "text": "Отличный пост!", "createdAt": "2025-02-22T12:00:00" }
  ],
  "count": 2
}
```
**Коды ошибок:**  404 (если пост не найден, либо можно возвращать пустой список если комментариев нет).

- **DELETE**  `/api/posts/comments/{commentId}` – *Удалить комментарий.*
  **Описание:**  Удаляет комментарий с идентификатором `{commentId}`. Доступно автору комментария, автору поста (владелец поста может удалять чужие комментарии под своим постом), либо администратору.
  **Ответ:**  200 OK или 204 No Content.
  **Коды ошибок:**  404 (комментарий не найден), 403 (нет прав).
  (Если Notification Service имеет внешние API, можно было бы добавить: GET `/api/notifications` – получить уведомления текущего пользователя; PUT/POST `/api/notifications/{id}/read` – пометить уведомление как прочитанное, и т.п. Но опустим детально.)***Общие моменты по API:**
- **Коды ответа:**  Сервис должен возвращать правильные HTTP-коды. 2xx – успех, 4xx – ошибки клиента (неправильный запрос, валидация, неавторизован, не найдены данные), 5xx – ошибки сервера.

- **Единый формат ошибок:**  Желательно выработать формат JSON для ошибок, например:

```json
{
  "error": "ValidationError",
  "message": "Username already exists",
  "details": { ... }
}
```
И соответствующий код 400 или 409. Это поможет клиентам обрабатывать ошибки.

- **Валидация данных:**  Все входящие данные проверяются – можно использовать Hibernate Validator/JSR-303 аннотации (@NotNull, @Size и т.д. в DTO) и Spring автоматически возвращает ошибку 400 с описанием.

- **Версионирование API:**  Пока не указывается (например, /api/v1/...), но в будущем возможен ввод версий.

## 7. База данных и ORM
В проекте используется реляционная база данных **PostgreSQL** . В рамках микросервисной архитектуры **каждый сервис будет иметь свою отдельную базу (или схему) данных**  для обеспечения слабой связанности. Таким образом:
- User Service использует свою базу для хранения пользователей и дружбы.

- Post Service – свою базу для постов, комментариев, лайков.

- Auth Service – в минимальном варианте не хранит данных, кроме возможно таблицы refresh-токенов или blacklist (если понадобится). Он обращается к базе User Service за учетными данными.

- Notification Service – свою таблицу уведомлений.
  Это повышает изоляцию (изменения схемы одного сервиса не влияют на другие) и масштабируемость, но требует взаимодействия через API для связи данных. **Альтернативный вариант**  – одна общая база с разными схемами или даже одной схемой, но микросервисный подход предпочитает раздельные хранилища.**Логическая схема БД (основные сущности и связи):** **User Service (БД пользователей):**
- **User**  (пользователь) – таблица `users`:
  Поля:
    - `id` (PK, serial/bigserial) – уникальный идентификатор пользователя.

    - `username` (varchar, уникальное) – логин.

    - `email` (varchar, уникальное) – email.

    - `password_hash` (varchar) – хэш пароля (например, длина 60 для BCrypt).

    - `name` (varchar) – отображаемое имя/полное имя.

    - `bio` (text) – информация "о себе".

    - `avatar` (varchar) – ссылка на аватар (URL или путь к файлу).

    - `created_at` (timestamp) – дата регистрации.

    - (прочие поля по требованию, например, `status`, `last_login` и др.)

- **Friendship**  (дружба/заявки) – таблица `friendships`:
    - `id` (PK).

    - `user_id` (FK → users.id).

    - `friend_id` (FK → users.id).

    - `status` (varchar) – статус отношения: `"PENDING"`, `"ACCEPTED"`, `"DECLINED"`.

    - `created_at` (timestamp) – дата создания заявки.

    - Уникальный составной индекс может быть на (user_id, friend_id) чтобы исключить дубли. Для симметричной дружбы можно при принятии создавать вторую запись наоборот или в запросах учитывать оба направления.

    - *Примечание:* Также можно модельировать дружбу как неориентированную связь одной записью со статусом, но тогда поиск "все друзья пользователя" требует OR условия (user_id = X OR friend_id = X). Для простоты можно хранить две записи при принятии – в обе стороны (что облегчает выборку друзей простым WHERE user_id = X).
      В ORM (Hibernate) может быть смоделировано как связь Many-to-Many:

```java
@ManyToMany
@JoinTable(name = "friendships",
    joinColumns = @JoinColumn(name = "user_id"),
    inverseJoinColumns = @JoinColumn(name = "friend_id"))
private Set<User> friends;
```
Однако из-за статуса и управления заявками, часто дружбу делают отдельной сущностью.
**Post Service (БД постов):**
- **Post**  (пост) – таблица `posts`:
    - `id` (PK).

    - `author_id` (FK → users.id, но **в данной базе**  нет таблицы users, т.к. отдельная БД, связь логическая. Можно хранить просто числовой идентификатор автора, полученный от User Service).

    - `content` (text) – текстовое содержимое поста.

    - `image_url` (varchar) – ссылка на прикрепленное изображение (если есть).

    - `created_at` (timestamp).

    - *Индексы:* на `author_id` (для выборки постов пользователя), на `created_at` (для сортировки/ленты).

- **Like**  (лайк) – таблица `likes`:
    - `id` (PK) – или можно без id, а составной ключ (user_id, post_id).

    - `post_id` (FK → posts.id).

    - `user_id` (FK логический на users.id).

    - `created_at` (timestamp).

    - Уникальный составной индекс на (user_id, post_id) чтобы предотвратить повторный лайк.

    - *Опционально:* поле `type` если планируются разные реакции (like, love, etc.), но пока только лайк.

- **Comment**  (комментарий) – таблица `comments`:
    - `id` (PK).

    - `post_id` (FK → posts.id).

    - `user_id` (FK логический на users.id, автор комментария).

    - `text` (text).

    - `created_at` (timestamp).

    - Индексы: на post_id (для быстрого получения всех комментариев поста), на user_id (комментарии пользователя, например, для модерации).

- Можно добавить **индексы полнотекстового поиска**  на content поста для будущей реализации поиска по постам (не в первой версии).
  **Notification Service (БД уведомлений):**  *(если реализуется)*
- **Notification**  – таблица `notifications`:
    - `id` (PK).

    - `user_id` (FK логический на users.id, кому адресовано уведомление).

    - `type` (varchar) – тип уведомления (FRIEND_REQUEST, NEW_MESSAGE, LIKE, COMMENT и т.д.).

    - `message` (text) – текст или JSON уведомления (например, можно хранить payload в JSONB).

    - `related_id` (integer) – id связанного объекта (например, id поста, комментария или пользователя-инициатора).

    - `read` (boolean) – флаг, прочитано или нет.

    - `created_at` (timestamp).

    - Индексы на user_id, возможно на read (для выборки непрочитанных).
      **Связи между сущностями (ER-диаграмма текстом):**
- Пользователь (User) 1 -- * Пост (Post)
  Один пользователь может иметь много постов (отношение "один ко многим" от User к Post). В базе Post Service это выражено хранением author_id в таблице posts.

- Пользователь (User) 1 -- * Комментарий (Comment)
  Один пользователь может написать много комментариев.

- Пост (Post) 1 -- * Комментарий (Comment)
  У одного поста может быть много комментариев, каждый комментарий связан с одним постом.

- Пользователь (User) * -- * Пост (Post) (через Like)
  Связь многие-ко-многим: пользователь может поставить лайки многим постам, и один пост может иметь много лайков от разных пользователей. Это реализовано отдельной таблицей likes.

- Пользователь (User) * -- * Пользователь (User) (через Friendship)
  Связь дружбы – многие ко многим на самой сущности User. Реализовано таблицей friendships, как описано выше. Каждая запись связывает две записи User (ориентированно как заявка или неориентированно как дружба).
  **Физическая схема БД:**
  Каждый сервис будет иметь свое подключение:
- User Service – своя БД (например, `social_userdb`) с таблицами `users`, `friendships`.

- Post Service – своя БД (например, `social_postdb`) с таблицами `posts`, `comments`, `likes`.

- (Auth Service может использовать `social_userdb` или отдельную `authdb` для refresh-token таблицы).

- Notification Service – `social_notifydb` с таблицей `notifications`.

В деплое все эти базы могут быть реализованы как отдельные схемы одной СУБД PostgreSQL на одном сервере или как разные экземпляры (в Docker Compose можно либо поднять несколько контейнеров Postgres, либо один с разными базами).
**ORM (Hibernate) – сопоставление сущностей:**
В приложении на Java каждая таблица соответствует классу-сущности, помеченному аннотацией `@Entity`. Используется **Spring Data JPA** , поэтому для каждой сущности будет свой интерфейс-репозиторий для стандартных операций.
Примеры Entity-классов:


```java
@Entity
@Table(name = "users")
public class User {
    @Id 
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable=false, unique=true)
    private String username;
    
    @Column(nullable=false, unique=true)
    private String email;
    
    @Column(name="password_hash", nullable=false)
    private String passwordHash;
    
    @Column
    private String name;
    
    @Column
    private String bio;
    
    @Column(name="avatar")
    private String avatarUrl;
    
    @Column(name="created_at")
    private LocalDateTime createdAt = LocalDateTime.now();
    
    // Связь Many-to-Many друзей (при желании в ORM, альтернативно через Friendship entity)
    @ManyToMany
    @JoinTable(name = "friendships",
        joinColumns = @JoinColumn(name="user_id"),
        inverseJoinColumns = @JoinColumn(name="friend_id"))
    private Set<User> friends = new HashSet<>();
    
    // getters and setters ...
}
```


```java
@Entity
@Table(name = "posts")
public class Post {
    @Id 
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name="author_id", nullable=false)
    private Long authorId;  // ссылается на User.id
    
    @Column(columnDefinition="TEXT", nullable=false)
    private String content;
    
    @Column(name="image_url")
    private String imageUrl;
    
    @Column(name="created_at")
    private LocalDateTime createdAt = LocalDateTime.now();
    
    // Не сохраняем счётчики лайков/комментариев как поля, они вычисляются при запросе (или поддерживаются через триггеры/агрегацию)
    
    // Можно также определить связь на Comments, но учитывая микросервис, комментарии могут быть в той же базе:
    // @OneToMany(mappedBy="postId", cascade=CascadeType.ALL)
    // private List<Comment> comments;
}
```
Приведенный класс `Post` хранит `authorId` как `Long` (идентификатор пользователя). В монолитном приложении мы бы сделали `@ManyToOne private User author;` для автоматического джоина на пользователя, но так как разные сервисы/базы, здесь `authorId` остается просто ID. Альтернативно, можно хранить только ID и при необходимости вручную запрашивать User Service для получения деталей автора.
Еще пример – сущность Friendship, если моделируется как отдельный класс:


```java
@Entity
@Table(name = "friendships")
public class Friendship {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name="user_id", nullable=false)
    private User user;
    
    @ManyToOne
    @JoinColumn(name="friend_id", nullable=false)
    private User friend;
    
    @Column(nullable=false)
    private String status;  // PENDING/ACCEPTED
    
    @Column(name="created_at")
    private LocalDateTime createdAt = LocalDateTime.now();
    // ...
}
```
Если Friendship используется, то поле `User.friends` можно убрать или сделать `@OneToMany(mappedBy="user")` на Friendship. В любом случае, ORM позволит запросить список друзей пользователя через либо `user.getFriends()` (если ManyToMany) либо `friendshipRepository.findAllByUser(user)`.**Миграции БД:**  Для создания схемы БД можно использовать либо auto-ddl (Hibernate `hibernate.ddl-auto=update` для разработки), либо использовать инструмент миграций, например **Flyway**  или **Liquibase**  – чтобы версионно управлять схемой. В ТЗ можно указать, что применится Flyway для автоматического применения SQL миграций при запуске (для каждого сервиса свой каталог миграций).**Транзакции и целостность:**
- В пределах одного микросервиса все операции, затрагивающие несколько таблиц, должны проходить внутри транзакций, чтобы сохранить консистентность данных. Например:
    - При регистрации пользователя: создание записи в `users` и, допустим, создание дефолтных настроек в другой таблице (если бы была) – в транзакции, чтобы либо все создалось, либо при ошибке откат.

    - При принятии дружбы: либо обновить запись дружбы на "ACCEPTED", либо создать две записи (в обе стороны) – всё это можно сделать в одной транзакции User Service. Если что-то пойдет не так (например, БД ошибка), транзакция откатится и ни одна из половин не будет сохранена (не будет "полудружбы").

    - В Post Service: добавление комментария может быть простой операцией (одна таблица), но, например, если при удалении поста нужно удалить пост и cascade-ом или последовательно удалить все комментарии и лайки – лучше обернуть в транзакцию, чтобы либо пост и все связанные комментарии/лайки удалились, либо в случае сбоя ничего не удалилось частично.

- Использование @Transactional (Spring) на сервис-слое обеспечивает, что метод с несколькими репозиторными вызовами выполняется атомарно. Например:

```java
@Service
public class FriendService {
    @Transactional
    public void acceptFriendRequest(Long userId, Long friendId) {
        Friendship req = friendshipRepo.findByUserIdAndFriendId(friendId, userId);
        if (req != null && req.getStatus().equals("PENDING")) {
            req.setStatus("ACCEPTED");
            friendshipRepo.save(req);
            // создаем ответную связь
            Friendship reciprocal = new Friendship(user, friend, "ACCEPTED");
            friendshipRepo.save(reciprocal);
        }
    }
}
```
Здесь, если второй `save` бросит исключение, весь метод откатится – запись `req` не сохранит статус "ACCEPTED" (т.к. транзакция откачена).

- Транзакции не распространяются между сервисами (нет распределенных транзакций ACID), поэтому при последовательных операциях в разных сервисах (например, создание пользователя в User Service и потом создание чего-то в Notification Service) – нужно проектировать так, чтобы либо достигалась **идемпотентность**  операций (повторный вызов дает тот же результат), либо использовать механизмы компенсации/саг (сложно для нашего объема). В нашем проекте кросс-сервисные транзакции минимизированы: в основном, один запрос = операция в одном сервисе.

- Также, на уровне базы, настроены **внешние ключи**  для локальных связей (например, comment.post_id → posts.id CASCADE DELETE, чтобы удаление поста могло каскадно удалить комментарии, если так настроим).

- **Rollback сценарии:**  Если при выполнении REST-запроса что-то не получилось (например, ошибка базы), сервис должен откатить транзакцию и вернуть клиенту соответствующий код 500 или 503. Логгирование ошибки произойдет, а система останется в предыдущем консистентном состоянии.

## 8. Безопасность

Безопасность приложения реализуется на нескольких уровнях:
**Аутентификация (Authentication):**
- Используется **JSON Web Token (JWT)**  для безнапасного хранения информации о сеансе пользователя. После успешного входа (логина) пользователь получает JWT, который хранится на клиенте (в памяти приложения или Secure Storage, для веба – в HTTPOnly cookie или локальном хранилище, с осторожностью).

- JWT содержит закодированную информацию (payload) – как минимум userId, а также время истечения `exp` и, возможно, роль пользователя. Пример payload (декодированный):

```json
{
  "sub": "123",        // идентификатор пользователя
  "role": "USER",      // роль
  "exp": 1719065930    // время истечения (UNIX timestamp)
}
```

- Токен подписан **секретным ключом**  (для HMAC, например HS256) либо **приватным ключом**  (для RSA/ECDSA). Выбор: для простоты начнем с HS256 и секретной фразы, хранимой в Auth Service и Gateway. В случае распределенных сервисов возможно использование RSA: Auth Service подписывает (приватный), Gateway и другие сервисы проверяют подпись публичным ключом – это безопаснее, т.к. приватный ключ не распространяется.

- **Хранение паролей:**  Пароли пользователей никогда не хранятся в открытом виде. При регистрации пароль сразу шифруется (хешируется) алгоритмом BCrypt (или Argon2) с солью. В базе хранится только хеш. При логине входящий пароль пропускается через ту же функцию и сравнивается с хешем.

- Auth Service отвечает за выдачу JWT. Он проверяет данные через User Service (получает хеш и сравнивает). JWT формируется с достаточным временем жизни (например, 1 час) и отдается клиенту. Возможно использование refresh-токена для обновления сеанса без повторного ввода пароля.
  **Авторизация (Authorization):**
- **Spring Security**  конфигурируется в каждом микросервисе, чтобы защищать эндпоинты. Однако, как упомянуто, часть проверки JWT выносится на Gateway.

- На **API Gateway**  настроены правила:
    - Разрешить без токена доступ только к определенным ресурсам: например, `/api/auth/login`, `/api/auth/register` (публичные), а также к статическим ресурсам, если таковые были.

    - Все остальные URL требуют присутствия валидного JWT. Для этого на Gateway применяется фильтр (например, `JwtAuthenticationFilter`), который:
        - Читает заголовок `Authorization`.

        - Если нет – возвращает 401 Unauthorized.

        - Если есть – парсит токен (через библиотеку, например, `io.jsonwebtoken.Jwts` или посредством Spring Security OAuth2 Resource Server).

        - Проверяет подпись (посредством секрета или публичного ключа). Если подпись неверна или токен истек – 401.

        - Если всё ок – извлекает данные пользователя (ид, роль) и помещает в SecurityContext (как аутентифицированного пользователя).

        - Далее Gateway решает, имеет ли пользователь право на запрошенный ресурс: например, если роль не подходит (попытка доступиться к админовскому URL обычным пользователем) – 403 Forbidden.

        - Затем Gateway **проксирует**  запрос на соответствующий микросервис, при этом **может добавлять заголовки** . Например, добавит заголовок `X-User-ID: 123` и `X-User-Role: USER` для внутреннего использования сервисами (чтобы они знали, кто запросил). Либо может передавать токен как есть, и каждый сервис снова выполнит ту же проверку (второй вариант – дублирование, но повышает безопасность).

    - Для реализации JWT на Gateway мы можем использовать Spring Security с **OAuth2 Resource Server**  возможностями: прописав `spring.security.oauth2.resourceserver.jwt.jwk-set-uri` (если RSA и есть jwk), либо `jwt.secret`. Тогда вся проверка делается автоматически на фильтре, а нам только настроить `.authorizeRequests`.

- **Spring Security в микросервисах:**
    - Внутренние сервисы (User, Post, etc.) тоже на Spring Boot, каждый может иметь свою SecurityConfig. Если мы доверяем Gateway, то внутренние сервисы могут принимать лишь запросы от Gateway (например, ограничив сетевой доступ). Однако на всякий случай, настроим и их так, чтобы они тоже умели проверять JWT (особенно полезно при тестировании сервисов напрямую).

    - Например, в User Service можно сконфигурировать Security так, чтобы все пути требуют аутентификации (кроме, может, `/actuator/health`). Он будет так же проверять токен с тем же секретом/публичным ключом. Благодаря этому, даже если кто-то обойдет Gateway (что маловероятно, если сеть изолирована), прямой доступ будет защищен.

    - *Роли и права:* В токен закодирована роль (`USER`, `ADMIN`). Spring Security позволит, например, пометить методы контроллеров аннотацией `@PreAuthorize("hasRole('ADMIN')")` – тогда при отсутствии нужной роли вернется 403. В User Service, например, эндпоинт удаления пользователя может требовать ADMIN.

    - Пользовательские ресурсы могут использовать проверку на идентичность: например, в контроллере профиля можно проверить, что `id` из пути совпадает с `id` текущего пользователя, иначе бросить AccessDenied. Это можно делать вручную или через Spring Security выражения.
        - Один из способов: настроить `@PreAuthorize("#id == authentication.principal.id or hasRole('ADMIN')")` на метод контроллера, чтобы разрешить либо владельцу, либо админу.

- **Защита от CSRF:**  Поскольку API предполагается использовать с JWT, а не cookies, и не предназначен для браузерных форм напрямую, CSRF не актуален (мы можем отключить CSRF защиту в Spring Security, т.к. нет состояния и cookies). Клиентские приложения сами заботятся о безопасном хранении токена.

- **Шифрование трафика:**  Предполагается, что общение с API Gateway будет происходить по HTTPS (особенно если развертывание в облаке или открыто в интернет). На этапе разработки Docker Compose можно не иметь SSL, но в продакшне – либо ставится обратный прокси (Nginx, AWS ELB) с SSL перед Gateway, либо Gateway настроен с SSL сертификатом.

- **Логирование и мониторинг безопасности:**
    - Все попытки аутентификации (успешные и неуспешные) фиксируются (например, логируются с указанием пользователя, IP, времени).

    - Подозрительная активность (много неудачных логинов) может отслеживаться и приводить к временной блокировке (brute-force protection) – можно добавить в дальнейших требованиях.

    - Доступ к важным системным ресурсам (например, админ-операции) дополнительно контролируется.

- **API Gateway безопасность:**
    - Gateway, помимо аутентификации, может выполнять **rate limiting**  – ограничивать частоту запросов от одного IP/токена, чтобы предотвращать злоупотребление (например, не дать спамить логин или комментирование).

    - Gateway **скрывает**  внутреннюю структуру – прямых обращений к микросервисам извне нет, поэтому внутренние сервисы могут быть доступны по непривычным портам и именам внутри Docker-сети. Это уже дополнительный уровень безопасности (security through obscurity, но в сочетании с реальной аутентификацией).

В итоге, используется комбинация: JWT + Spring Security + разграничение ролей, что обеспечивает безопасность API. Важным является правильная настройка CORS (разрешить запросы только с доверенных доменов фронтенда) на Gateway, защита конфиденциальных данных (не возвращать лишнее, например, хеши паролей никогда не выдаются), и обновление зависимостей (безопасность кода).

## 9. DevOps и инфраструктура

Для проекта предусмотрены процессы контейнеризации, развертывания и CI/CD.
**Docker контейнеризация:**
- Каждый микросервис (Gateway, Auth, User, Post, Notification) имеет свой **Dockerfile**  для сборки образа. Базовым образом будет официальное **openjdk**  (например, `openjdk:17-jdk-slim`) для запуска Java.

- Процесс сборки: сначала проект собирается с помощью Maven/Gradle, получаем исполняемый jar-файл (Spring Boot создает fat jar). Затем Dockerfile копирует этот jar в образ.

- Возможно использование multi-stage Dockerfile: сначала stage на maven:3.8-jdk-17 для сборки, потом результат в slim runtime образ. Это позволит не тянуть Maven и исходники в финальный образ.

- Пример Dockerfile (для User Service):

```dockerfile
FROM maven:3.8.6-openjdk-17 AS build
WORKDIR /app
COPY pom.xml ./
COPY src ./src
RUN mvn clean package -DskipTests

FROM openjdk:17-jdk-slim
WORKDIR /app
COPY --from=build /app/target/user-service.jar ./user-service.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "user-service.jar"]
```
Аналогичные Dockerfile для других сервисов (меняется только имя jar). Для Auth Service можно назвать `auth-service.jar`, и т.д. API Gateway – `gateway.jar`.

- Для базы данных PostgreSQL не нужно писать Dockerfile – используется официальный образ `postgres:14-alpine` с указанием параметров (пароль, БД).

- **Конфигурация через переменные окружения:**  В Docker Compose (или k8s) задаются переменные, которые Spring Boot приложения читают (например, `SPRING_DATASOURCE_URL`, `SPRING_DATASOURCE_USERNAME`, `SPRING_DATASOURCE_PASSWORD` для настройки подключения к БД; `JWT_SECRET` для секретной фразы; `EUREKA_SERVER` если был, и т.д.). Это позволяет не хардкодить конфигурацию в образ, а задавать при деплое. В `application.properties` могут быть placeholders, либо используется Spring Cloud Config (в перспективе).
  **Docker Compose (локальное развертывание и отладка):**
- Будет создан файл `docker-compose.yml`, описывающий все сервисы, их образы и связь сети. Например:

```yaml
version: '3.8'
services:
  database_users:
    image: postgres:14-alpine
    environment:
      - POSTGRES_USER=social
      - POSTGRES_PASSWORD=socialpass
      - POSTGRES_DB=social_userdb
    volumes:
      - db_users_data:/var/lib/postgresql/data
    networks:
      - socialnet
  database_posts:
    image: postgres:14-alpine
    environment:
      - POSTGRES_USER=social
      - POSTGRES_PASSWORD=socialpass
      - POSTGRES_DB=social_postdb
    networks:
      - socialnet
  auth-service:
    build: ./auth-service
    environment:
      - SPRING_DATASOURCE_URL=jdbc:postgresql://database_users:5432/social_userdb
      - SPRING_DATASOURCE_USERNAME=social
      - SPRING_DATASOURCE_PASSWORD=socialpass
      - JWT_SECRET=MySuperSecretKey
    depends_on:
      - database_users
    networks:
      - socialnet
  user-service:
    build: ./user-service
    environment:
      - SPRING_DATASOURCE_URL=jdbc:postgresql://database_users:5432/social_userdb
      - SPRING_DATASOURCE_USERNAME=social
      - SPRING_DATASOURCE_PASSWORD=socialpass
    depends_on:
      - database_users
    networks:
      - socialnet
  post-service:
    build: ./post-service
    environment:
      - SPRING_DATASOURCE_URL=jdbc:postgresql://database_posts:5432/social_postdb
      - SPRING_DATASOURCE_USERNAME=social
      - SPRING_DATASOURCE_PASSWORD=socialpass
    depends_on:
      - database_posts
    networks:
      - socialnet
  gateway:
    build: ./gateway
    ports:
      - "8080:8080"   # внешний порт
    depends_on:
      - auth-service
      - user-service
      - post-service
    networks:
      - socialnet
networks:
  socialnet:
    driver: bridge
volumes:
  db_users_data:
  db_posts_data:
```
Здесь определены два контейнера Postgres (для разных сервисов) и контейнеры для каждого сервисного приложения. Все они в одной сети `socialnet`, чтобы видеть друг друга по именам (например, `database_users`).

- Compose позволяет разработчику запустить командой `docker-compose up --build` сразу все сервисы. После этого API Gateway будет доступен на `localhost:8080` (по настройке порта).

- Для деплоя на сервер (production) можно использовать похожий compose (с образами, загруженными из registry), либо использовать оркестратор.
  **CI/CD (Continuous Integration / Continuous Deployment):**
- **Репозиторий GitHub (или GitLab):**  Включены автоматические действия при изменении кода.

- **CI (Continuous Integration):**  Настроены GitHub Actions workflows (либо Jenkins pipelines, если компания использует Jenkins):
    - На каждый Pull Request и на каждое слияние в develop/main запускается сборка проекта:
        - Шаги: checkout репозитория, установка JDK 17, сборка с Maven/Gradle (`mvn clean verify` или `./gradlew build`).

        - Запуск юнит-тестов. Если какие-либо тесты падают – сборка помечается как fail, разработчики оповещаются, PR не сливается.

        - Отчет о покрытии (можно интегрировать Jacoco и выводить %).

    - Если все тесты успешны, можно настроить сборку Docker-образов:
        - CI может запускать `docker build` для каждого модуля и `docker push` в registry (например, Docker Hub или GitHub Packages). Тэг образа может включать номер версии или хэш коммита.

    - Также можно генерировать артефакт – fat jars для каждого сервиса.

- **CD (Continuous Deployment/Delivery):**
    - Для среды staging/test: После успешной сборки в ветке develop, CI/CD может автоматически развернуть новые образы на тестовый сервер. Например, если используется Docker Compose, то удаленно выполняется `docker-compose pull && docker-compose up -d` с новыми образами.

    - Для продакшена: Развертывание идет из main (release) ветки. Можно настроить ручной триггер деплоя (чтобы ответственный человек нажал кнопку для деплоя).

    - При деплое применяются миграции базы (Flyway автоматически на старте сервисов применит).

    - В случае Kubernetes: настроены манифесты или Helm-чарты, а CI/CD обновляет Deployment, например, посредством `kubectl apply` или через ArgoCD.

- **Мониторинг CI/CD:**
    - Хранится история сборок, их статусы.

    - При неудачных сборках отправляются уведомления в командный чат/почту.

    - При деплое логируются шаги.

- **Резервное копирование БД:**  На уровне DevOps учитывается регулярный backup PostgreSQL (например, ежедневный дамп), и возможность восстановления.

- **Scale/Replicas:**  Если ожидается высокая нагрузка, инфраструктура описывает возможность масштабирования: например, запуск N экземпляров post-service, user-service. В Docker Compose можно задать `replicas: 3` (в Swarm) или в k8s – `replicas` in Deployment.
  **Пример GitHub Actions workflow (yaml схематично):**

```yaml
name: CI Build

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
    - name: Build and Test
      run: mvn clean verify
    - name: Build Docker Images
      run: |
        docker build -t myrepo/user-service:latest user-service/
        docker build -t myrepo/post-service:latest post-service/
    - name: Push Docker Images
      run: |
        echo "${{ secrets.DOCKER_PASS }}" | docker login -u "${{ secrets.DOCKER_USER }}" --password-stdin
        docker push myrepo/user-service:latest
        docker push myrepo/post-service:latest
```
*(Это упрощенно, в реальности возможно разбить по сервисам, добавить тегирование по Git тегам и т.д.)*
Таким образом, инфраструктурный процесс обеспечивает, что код проверен, собрание артефактов автоматизировано, и развертывание происходит надежно с минимальным ручным вмешательством.

## 10. Тестирование

Для обеспечения качества и отсутствия регрессий, в проекте проводится всестороннее тестирование, охватывающее модульные и интеграционные тесты.
**Модульное тестирование (Unit-testing):**
- Осуществляется с помощью **JUnit 5**  (Jupiter). Каждый сервис будет иметь набор модульных тестов, покрывающих бизнес-логику сервис-слоя и утилит.

- Модульные тесты фокусируются на отдельном методе или классе без поднятия всего Spring контекста (т.е. максимально изолировано, быстро).

- **Mockito**  используется для создания **Mock-объектов**  зависимостей: например, тестируя сервис пользователей, мы мокируем UserRepository, или внешний вызов (например, AuthServiceTest будет мокировать вызов UserService).

- Пример модульного теста для сервиса (на примере UserService):

```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    @Mock
    private UserRepository userRepository;
    @Mock
    private PasswordEncoder passwordEncoder;
    @InjectMocks
    private UserService userService;
    
    @Test
    void testRegisterUser_Success() {
        // given
        UserRegistrationRequest req = new UserRegistrationRequest("john", "john@example.com", "pass123");
        when(userRepository.existsByUsername("john")).thenReturn(false);
        when(passwordEncoder.encode("pass123")).thenReturn("hashedPass");
        
        // when
        User user = userService.registerUser(req);
        
        // then
        assertNotNull(user.getId());
        assertEquals("john", user.getUsername());
        assertEquals("hashedPass", user.getPasswordHash());
        verify(userRepository).save(any(User.class));
    }
    
    @Test
    void testRegisterUser_Fail_DuplicateUsername() {
        // given
        UserRegistrationRequest req = new UserRegistrationRequest("john", "john@example.com", "pass123");
        when(userRepository.existsByUsername("john")).thenReturn(true);
        
        // when & then
        assertThrows(UsernameAlreadyExistsException.class, () -> {
            userService.registerUser(req);
        });
        verify(userRepository, never()).save(any());
    }
}
```
Здесь мы проверяем успешную регистрацию и случай с дублирующимся именем. `PasswordEncoder` замокан для изоляции.

- Модульные тесты контроллеров можно писать используя **MockMvc**  (Spring Boot test), либо, более изолированно, мокируя сервис-слой:

```java
@WebMvcTest(UserController.class)
class UserControllerTest {
    @Autowired MockMvc mockMvc;
    @MockBean UserService userService;
    
    @Test
    void getUserProfile_ReturnsProfile() throws Exception {
        UserDto dto = new UserDto(123L, "john", "John Doe", "Hello!", "/avatar.jpg");
        when(userService.getProfile(123L)).thenReturn(dto);
        
        mockMvc.perform(get("/api/users/123").header("Authorization", "Bearer valid.jwt.token"))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.id").value(123))
               .andExpect(jsonPath("$.username").value("john"));
    }
}
```
Тут мы используем MockMvc для эмуляции HTTP-запроса к контроллеру, подставляя заглушку сервиса.

- Цель – достичь покрытия ключевой логики не менее 80%.
  **Интеграционное тестирование:**
- Некоторые тесты запускаются с поднятием Spring-контекста и реальной базой (например, H2 in-memory) для проверки взаимодействия с базой данных, репозиториями JPA.

- Например, тест репозитория UserRepository с H2: сохранить пользователя и затем найти – убедиться, что данные сохраняются и извлекаются правильно, а ограничения (уникальность) работают.

- Тесты сервисов с базой: можно запустить тестовый контекст, подключенный к H2, с реальным `userRepository` и `friendshipRepository`. Операции будут выполняться транзакционно, и после теста либо @Transactional и rollback, либо вручную очистка.

- **Integration tests межсервисного взаимодействия:**  В рамках одного микросервиса можно замокировать вызовы внешних сервисов (например, PostServiceTest может мокировать UserServiceClient). Однако, также можно написать **контрактные тесты**  или **API тесты** : поднять все сервисы (например, используя Spring Boot и аннотации @SpringBootTest(webEnvironment = RANDOM_PORT) + @ActiveProfiles("test")) и выполнить реальные HTTP-вызовы. Это приближается к end-to-end тестам.

- Для упрощения, можно протестировать API Gateway + один сервис:
    - Поднять Gateway и моковый ответ вместо реального сервиса (с помощью WireMock).

    - Либо поднять все (сложно без оркестрации).
      На начальном этапе, для кросс-сервис, полагаемся на правильность контрактов.
      **Тестирование безопасности:**
- Написать тесты на то, что защищенные эндпоинты недоступны без JWT (ожидаем 401).

- Тесты на доступ с разными ролями: например, с JWT с ролью USER пытаемся удалить пост другого – ожидаем 403.

- Можем использовать MockMvc и подменять SecurityContext с разными Authentication (Spring Security Test позволяет `withMockUser`).

- Также библиотека **Keycloak**  или **OAuth2**  test utilities могут помочь, но можно и вручную.
  **Mock-тесты (с использованием Mock объектов):**
- Под этим подразумевается использование Mockito как выше, и тесты, где взаимодействие между сервисами симулируется. Например, **AuthServiceTest**  может замокировать UserService client:

```java
when(userClient.getUserByUsername("john")).thenReturn(new UserDto(...));
```
– таким образом, проверяем логику AuthService (вернет ли он JWT при правильном ответе).

- **Тестирование контроллеров** : вместо реального выполнения всей логики, мы подставляем Mock сервис (как показано в UserControllerTest). Это позволяет проверить правильность HTTP статус-кодов, структуры JSON, маппинга URL -> метод контроллера.

- **TDD подход:**  по возможности, писать тесты до или параллельно с разработкой функций.
  **Дополнительно:**
- Настроить **CI**  (упомянуто выше) так, чтобы тесты запускались при каждом коммите.

- Использовать статический анализатор (**SpotBugs, Checkstyle, SonarQube** ) для контроля качества (вне рамок самого кода, но может быть частью quality gate).

- **Load testing (нагрузочное тестирование)** : Отдельно, нефункциональное требование – можно применить JMeter, Gatling или k6 для имитации нагрузки (например, N параллельных пользователей запросы на ленту) и измерения производительности. Эти тесты обычно не в unit, а проводятся вручную или на отдельном этапе pipeline.

Результатом будет надежный код, покрытый тестами, что снизит число багов при изменениях и обеспечит соответствие реализаций требованиям.

## 11. Работа с Git
В рамках проекта используется система контроля версий **Git**  и принята веточная модель **Gitflow**  для упорядочивания разработки. Ниже описаны правила работы с репозиторием:**Gitflow Workflow:**
- **Основные ветки:**
    - **main**  (или master) – главная ветка, содержащая стабильный код, готовый для релиза/деплоя. В эту ветку изменения попадают только после релизной подготовки и тестирования.

    - **develop**  – основная ветка разработки, куда интегрируются все фичи после завершения и код-ревью. Эта ветка всегда содержит актуальные наработки, проходит интеграционное тестирование и отражает следующий потенциальный релиз.

- **Ветки для разработки функционала:**
    - **feature/***  – для каждой новой фичи или задачи создается отдельная ветка от `develop`. Название ветки должно кратко отражать суть задачи или ID задачи из трекера, например: `feature/user-registration`, `feature/friendship-requests`.

    - Разработчик ведет работу в своей feature-ветке, коммитит изменения (см. ниже про сообщения) и после завершения создает Pull Request (PR) на слияние в `develop`.

    - Другой разработчик или лид проводит **code review**  PR. После одобрения PR сливается (Merge) в develop. Лучше использовать `Squash and merge` или `Rebase` слияние, чтобы история была линейной, но это по договоренности команды.

- **Релизные ветки:**
    - **release/***  – когда накоплено достаточное количество функционала на develop и нужно готовить релиз, от ветки develop создается release-ветка, например `release/1.0.0`.

    - В ней можно делать только мелкие правки, багфиксы, обновление версии и документации. После тестирования, эта ветка сливается в main (тем самым делая релиз), а также обратно в develop (чтобы перенести сделанные правки).

- **Горячие исправления:**
    - **hotfix/***  – если в продакшене (main) найден критичный баг, создается ветка hotfix от main, в ней делается исправление, затем она сливается обратно в main **и**  в develop (чтобы фиксы не потерялись в текущей разработке). Например, `hotfix/fix-nullpointer-feed`.

    - После мержа hotfix ветки в main, тегируется новая версия (например, 1.0.1).

- **Теги (tags):**  Все релизы, попавшие в main, помечаются тегами по семантическому versioning, например `v1.0.0`, `v1.1.0`. Это удобно для отслеживания версий и сборки образов.
  **Правила коммитов:**
- Коммиты должны быть **атомарными**  и понятными. Один коммит – одна логическая завершенная часть работы (например, "добавлен метод X", "исправлен баг Y").

- Сообщения коммитов пишутся на **английском языке**  (общая практика) или согласованно на русском, но английский предпочтителен для общепринятой читаемости.

- Используется стиль сообщений, например, **Conventional Commits** :
    - `feat: описание` – для нового функционала (feature).

    - `fix: описание` – для исправления бага.

    - `docs: ...` – изменения только в документации.

    - `refactor: ...` – рефакторинг кода без изменения функционала.

    - `test: ...` – добавление или исправление тестов.

    - `chore: ...` – обновление конфигураций, сборки, не влияющее на логику.
      Пример: `feat: implement JWT token verification in Gateway` или `fix: handle null user profile image`.

- В описание коммита (после заголовка) при необходимости добавляется более подробный текст: что сделано, зачем, возможно, ссылка на задачу или тикет.

- **Связь с таск-трекером:**  Если используется система управления задачами (JIRA, Trello, GitHub Issues), в сообщении коммита или PR указывается ID задачи, например: `feat: add email confirmation (SOCNET-42)`.

- **Pull Request** : при слиянии feature-ветки в develop пишется описание PR, что за изменения, как протестировано. После мержа, GitHub может сгенерировать squash-коммит с комбинированным сообщением.

- **Мержи** : Прямые коммиты в develop/main запрещены – только через PR и review. Это обеспечивает качество кода и соответствие стандартам.

- **Code style:**  Используется единый стиль кодирования (например, Google Java Style или Spring style). Для автоформатирования могут быть настроены Checkstyle/Spotless, чтобы PR не содержали стилистических разногласий.

Следуя Gitflow и правилам коммитов, команда сможет параллельно работать над разными задачами, минимизируя конфликты и обеспечивая чистую историю, что упрощает отладку и поддержку проекта.

## 12. Нефункциональные требования

Помимо бизнес-функций, система должна удовлетворять ряду нефункциональных требований: производительность, масштабируемость, надежность, и быть сопровождаемой (логируемой и мониторируемой).
**Производительность:**
- **Время отклика API:**  Ключевые операции (получение ленты, логин, загрузка профиля) должны выполняться быстро. Целевой показатель – среднее время отклика не более 200 мс для простых запросов (при разумной нагрузке), не более 500 мс для более тяжелых (например, генерация ленты). Максимально допустимое время для любой операции – 2 секунды (95-й перцентиль). Длительные операции (если появятся, например, генерация большого отчета) должны выполняться асинхронно.

- **Количество одновременных пользователей:**  Система должна выдерживать одновременно, минимум, скажем, **1000 активных пользователей** , совершающих действия. Это подразумевает, что REST API должен поддерживать порядка десятков запросов в секунду стабильно.

- **Оптимизация запросов:**  Использовать ленивую загрузку данных в ORM, чтобы не вытягивать лишние связанные сущности без надобности (или DTO на уровне сервисов). Применять пагинацию для списков (друзья, лента, комментарии) – ограничивать, например, 20-50 элементов за раз, с параметром `page`.

- **Кэширование:**  Реализовать кэш там, где возможны повторяющиеся запросы. Например, кэшировать информацию профиля пользователя (User Service) на короткое время, чтобы при массовой выдаче ленты (когда нужно имя автора поста) не обращаться к БД многократно. Spring Cache может быть использован с caffeine/Guava для памяти. Также HTTP-клиентам можно использовать ETag/Last-Modified заголовки для кэширования статичных ресурсов (но у нас в основном динамика).

- **Нагрузочное тестирование:**  Перед релизом провести нагрузочные тесты, выявить узкие места. Если, например, генерация ленты слишком медленная, рассмотреть оптимизацию запросов (JOIN-ы вместо отдельных запросов per friend, или предвычисление ленты).

- **Вычислительная эффективность:**  Избегать тяжелых операций в горячем контуре (например, не выполнять криптографию на каждый запрос, кроме JWT проверки которая оптимизирована). Если нужно, внедрить пулы потоков для определенных задач (но Spring Boot webflux не используется, у нас Spring MVC, который сам по себе потокобезопасен с пулом Tomcat threads).
  **Масштабируемость:**
- Архитектура изначально микросервисная, что предполагает **горизонтальное масштабирование** :
    - Каждый сервис может быть запущен в нескольких экземплярах (контейнерах/узлах). Не хранится состояние в памяти, которое бы препятствовало этому (приложения стателесс, кроме кеша, который локален).

    - Масштабирование базы данных: при увеличении нагрузки можно повысить характеристики СУБД (вертикально) или настроить **репликацию**  PostgreSQL для распределения чтений (отдельный ведущий на запись, реплики для чтения). Например, лента – тяжелое чтение – можно направлять на реплики (требует поддержки в приложении).

    - При крайней необходимости, возможно разделение данных по разным базам (sharding) – например, распределение пользователей по нескольким базам, но это вне рамок MVP.

- **Балансировка нагрузки:**  Предполагается, что перед API Gateway может стоять балансировщик (например, Nginx или AWS ELB), который распределяет входящий трафик между несколькими экземплярами Gateway. Gateway, в свою очередь, будет распределять к нескольким экземплярам микросервисов (если их несколько, через механизм, например, round-robin либо через service discovery).

- **Модульность и расширяемость:**  Новые функции могут добавляться новыми сервисами, не затрагивая существующие (например, добавить Chat Service – будет отдельный сервис). Существующие API могут версионироваться для изменений, сохраняя старые для совместимости.

- **Capacities:**  Система должна поддерживать рост пользователей до, скажем, 100k без кардинальной переработки (естественно, нужно будет масштабировать окружение). Код и архитектура не должны содержать жестких ограничений (например, использовать типы данных, в которых userId максимум 2^31; стараться использовать Long).

- **Отделение чтения и записи:**  Если наблюдается, что чтений (например, просмотра профилей, постов) значительно больше, можно выносить их на отдельные оптимизированные сервисы (CQRS принцип). Пока закладывается, что один и тот же сервис справляется и с CRUD, и с чтениями.
  **Отказоустойчивость и надежность:**
- **Обработка ошибок:**  Система должна корректно обрабатывать все предвиденные ошибки (например, нет такого пользователя, неправильный ввод) – возвращая соответствующие ответы, не падая с исключением без ответа.

- **Fault isolation:**  Если один микросервис падает или недоступен (например, Post Service не работает), это не должно приводить к полному коллапсу системы. API Gateway может возвращать временный ответ или прокинуть ошибку клиенту для этой функции, но **другие сервисы должны продолжать работать** .
    - Пример: если не работает Notification Service, то основные функции (постинг, дружба) продолжают работать; пользователи просто временно не получают уведомления.

    - Если не работает Post Service, пользователи не видят ленту, но могут, например, все еще дружить, переписываться (если б был чат).

- **Автоматическое восстановление:**  Все приложения работают в Docker – при сбое контейнер перезапускается (Docker restart policy "always" или orchestrator restart). Кроме того, можно настроить **Health Check**  для контейнеров: периодически проверять `/actuator/health` каждого сервиса, и если он не отвечает – перезапускать контейнер.

- **Circuit Breaker:**  Для межсервисных вызовов, особенно синхронных, внедряется шаблон **Circuit Breaker**  (например, библиотека Resilience4j). Например, если User Service лежит, Post Service при запросе друзей может сразу получать отказ (и не тратить время на долгие таймауты), возможно, возвращая пустую ленту с сообщением "try later".

- **Timeouts и Retry:**  Внешние вызовы (REST вызовы между сервисами) должны иметь разумные таймауты (например, 2 секунды). При превышении – бросать исключение. Можно реализовать повтор вызова (retry) 1-2 раза на случай временного сбоя, используя Resilience4j или Spring Retry.

- **Консистентность данных:**  За счет транзакций и carefully orchestrated flows, данные не должны теряться или переходить в неконсистентное состояние.
    - Важные изменения можно записывать в лог или отдельную "event" таблицу, чтобы потом восстановить, если последующая часть не удалась. Например, если User Service зарегистрировал пользователя, а в Notification Service не дошел запрос на приветственное уведомление – уведомление можно послать позже вручную, это не критично. Критичные же вещи (например, денежные транзакции – у нас нет таковых) отсутствуют, поэтому eventual consistency приемлема.

- **Бэкапы и миграции:**  Как упоминалось, регулярное резервирование БД.
    - При обновлении схемы БД (миграции) – убедиться, что миграции не приводят к даунтайму: возможно, применять сBackward совместимые изменения сначала (Blue-Green Deployment). Пока в MVP можно допускать короткий простой на миграцию.

- **High Availability:**  Если требуется 24/7 работа, то на проде должно быть минимум по 2 экземпляра критичных сервисов на разных узлах, + реплика БД. Хотя MVP может работать и с одним, закладываем возможность HA.
  **Логирование:**
- В каждой службе будет настроен логгер (SLF4J + Logback, который по дефолту с Spring Boot). Логирование разделяется по уровням:
    - **INFO:**  значимые события, например, запуск приложения, успешные ключевые действия (пользователь зарегистрировался, пост опубликован – можно логировать ID).

    - **DEBUG:**  подробная информация для отладки (SQL-запросы, межсервисные запросы). В продакшене уровень DEBUG отключен, но может быть включен при необходимости.

    - **ERROR:**  ошибки, исключения – с стектрейсом. Каждая ошибка сопровождается понятным сообщением.

    - **WARN:**  потенциально неправильные ситуации (например, попытка логина с невалидным токеном – можно как WARN).

- **Формат логов:**  стандартный – время, уровень, имя приложения/сервиса, сообщение. Можно добавить traceId (из Spring Cloud Sleuth, например) чтобы собрать цепочку вызовов.

- **Централизованное логирование:**  В контейнерах логи пишутся в stdout/stderr, Docker их собирает. Желательно настроить ELK-стек (ElasticSearch + Logstash + Kibana) или более легковесную систему (EFK с Fluentd) для агрегации логов. Тогда можно в Kibana фильтровать по сервису, уровню, времени. Это вне рамок MVP, но упоминается.

- **Сохранение аудита:**  Можно логировать действия пользователя (audit log) – например, "User X changed profile", "User Y deleted post Z". Это для отладки проблем и безопасности. Возможно, хранить такие логи дольше.
  **Мониторинг:**
- **Spring Boot Actuator:**  подключен во все сервисы. Он дает:
    - `/actuator/health` – для проверок живости (используется Docker/K8s).

    - `/actuator/metrics` – метрики (через Micrometer).

    - `/actuator/prometheus` – если подключен Prometheus, можно собирать метрики (количество запросов, время ответа, использование памяти).

- **Метрики:**  В частности, важно мониторить:
    - Количество запросов к каждому эндпоинту, среднее время, процент ошибок (5xx).

    - Utilization CPU, память каждого контейнера (в Docker or orchestrator).

    - Количество активных сессий (в нашем случае сессий нет, JWT, но можно считать активных пользователей по логинам в последний час).

    - Очередь запросов (в thread pool) – чтобы знать, не перегружен ли сервис.

- **Алармы:**  Настраиваются предупреждения:
    - Если сервис недоступен (Healthcheck fail) – уведомление DevOps.

    - Если время ответа или ошибка rate превышает порог – тоже сигнал.

    - База данных: мониторинг репликации, места на диске.

- **Профайлинг:**  Для выявления узких мест возможно использование APM (Application Performance Management) – например, Spring Boot devtools or Glowroot, или коммерческих (NewRelic, AppDynamics) – не в рамках изначальной разработки, но иметь в виду.
  **Безопасность (нефункциональные):**
- Обновление зависимостей при выходе security-патчей (Spring, Jackson и прочее) – чтобы не было уязвимостей.

- Проведение пенетрейшн-тестов (в будущем) – проверить, что API защищен от SQL-инъекций (ORM сам экранирует, если не пишем сырые SQL), XSS (у нас бэкенд, но stored XSS через хранение скриптов – надо фильтровать пользовательский ввод, например, в постах), CSRF (JWT + отсутствие cookies mitigate), brute force (лимитировать логин, как сказано).

- Соответствие GDPR, если предполагаются реальные пользователи (обработка персональных данных, право на удаление аккаунта – можно добавить API delete account).

Все эти меры обеспечат надежную, эффективную и масштабируемую работу социальной сети даже при росте числа пользователей и данных.

## 13. Приложения
**13.1 Схемы и диаграммы:** *(Здесь привели бы диаграммы, если бы визуально. Описываем текстово.)*
- **Диаграмма микросервисной архитектуры (Deployment diagram):**  Все сервисы (Auth, User, Post, Notification, Gateway) запущены в Docker-контейнерах. Клиент (браузер/мобильное приложение) обращается к API Gateway (http/https). Gateway раздает на сервисы. Сервисы User и Post имеют подключение к своим PostgreSQL базам (также в контейнерах). Notification Service, если есть, подключен к своей БД и, возможно, к брокеру сообщений (RabbitMQ, тоже контейнер). Все контейнеры в общей сети. Вне Docker – разработчик с CI, пушит код -> CI -> Registry -> Deploy. (Диаграмма последовательности: на примере запроса ленты – клиент -> gateway -> post service -> (post->user service) -> gateway -> клиент.)

- **ER-диаграмма базы данных:**
  Пользователь --< Дружба >-- Пользователь (многие-ко-многим самосвязанная).
  Пользователь --< Пост (один ко многим).
  Пост --< Комментарий (один ко многим).
  Пользователь --< Комментарий (один ко многим).
  Пользователь --< Лайк >-- Пост (многие-ко-многим через Like).
  (Если рисовать, прямоугольники: User, Post, Comment, Like, Friendship и связи линиями с пометками 1..*, etc.)

- **Диаграмма последовательности (Sequence diagram)**  например, для сценария "Пользователь публикует пост":
  Пользователь -> Gateway (POST /api/posts) -> PostService (создать пост) -> БД Post (INSERT) -> PostService (сохраняет пост) -> (опционально: PostService -> NotificationService "новый пост" -> ...) -> Gateway <- PostService (201 Created, post data) -> Пользователь (получает ответ). JWT используется, Gateway проверяет JWT перед проксированием.

- **Диаграмма компонентов:**  каждый микросервис = отдельный компонент с интерфейсами (REST API). Gateway компонент, DB компоненты.
  *(Если бы оформлялось на бумаге, тут могли бы быть UML-диаграммы.)***14.2 Список используемых библиотек и технологий:**
- **Язык программирования:**  Java 17

- **Фреймворк:**  Spring Boot 3.x (Spring Framework 6.x)
    - Spring Web (Spring MVC) – для REST контроллеров.

    - Spring Data JPA – для работы с БД (Hibernate ORM 6.x под капотом).

    - Spring Security – для безопасности (аутентификация JWT).

    - Spring Cloud Gateway – для реализации API Gateway.

    - Spring Boot Actuator – для мониторинга (метрики, health-check).

- **Библиотеки:**
    - **JWT:**  jjwt (io.jsonwebtoken) или использование Spring Security OAuth2 Resource Server JWT.

    - **Validation:**  Hibernate Validator (JSR 380) – встроен в Spring Boot Starter Validation.

    - **Lombok:**  для генерации методов (опционально, чтобы уменьшить шаблонный код).

    - **Model Mapper или MapStruct:**  для преобразования Entity -> DTO (по желанию, вручную можно обойтись).

    - **Logback**  (по умолчанию с Spring Boot) для логирования.

    - **JUnit 5**  + **Mockito**  + **Spring Boot Test**  + **AssertJ**  – для тестирования.

    - **Swagger**  (Springdoc OpenAPI 3) – для документирования API: генерирует /v3/api-docs и UI.

    - **Resilience4j:**  (опционально для circuit breaker, retry).

    - **Feign Client:**  (если использовать для вызовов между микросервисами вместо RestTemplate).

- **СУБД:**  PostgreSQL 14 (JDBC Driver: org.postgresql)

- **Контейнеризация:**  Docker 20+, Docker Compose v3

- **CI/CD:**  GitHub Actions (yaml pipeline), альтернатива Jenkins Pipeline.

- **Система контроля версий:**  Git (GitHub repository).

- **Инструменты разработчика:**
    - Maven 3.8 / Gradle 7 (Maven выбран, например).

    - IDE: IntelliJ IDEA / Eclipse for coding (разработчики).

    - Postman / curl для тестирования API вручную.

    - pgAdmin для управления БД (в Dev).

- **Средства мониторинга (планируемые):**
    - Prometheus + Grafana (для метрик).

    - ELK Stack (Elasticsearch, Logstash, Kibana) для логов, или Loki + Grafana as alternative.

    - Zipkin/Jaeger (если решим трассировку распределенных запросов делать).

- **Прочее:**
    - GitHub (репозиторий, трекинг задач через Issues/Projects).

    - Slack/Teams – коммуникация команды.

    - Wiki/Confluence – для ведения документации (включая это ТЗ).
      **14.3 Кодовые примеры (избранные фрагменты):**
- Пример конфигурации Spring Security (JWT фильтр) для Gateway:

```java
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.csrf().disable();
        http.authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**").permitAll()
                .anyRequest().authenticated()
        );
        // JWT filter
        http.oauth2ResourceServer()
            .jwt()  // assuming JWT validation via public key or secret configured
            .jwtAuthenticationConverter(customConverter()); // if we need custom principal
        return http.build();
    }
    // Bean for JwtDecoder or others if needed
}
```
Это пример, реальная конфигурация может отличаться (например, использовать OncePerRequestFilter, если кастомная логика).

- Пример контроллера в Post Service (создание поста):

```java
@RestController
@RequestMapping("/api/posts")
public class PostController {
    @Autowired
    private PostService postService;
    
    @PostMapping
    public ResponseEntity<PostDto> createPost(@RequestBody CreatePostRequest request,
                                             @AuthenticationPrincipal Jwt jwt) {
        // @AuthenticationPrincipal Jwt jwt – если настроен Resource Server, jwt содержит токен инфо
        Long userId = Long.valueOf(jwt.getSubject());
        PostDto created = postService.createPost(userId, request);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }
}
```
Здесь `CreatePostRequest` – DTO с полем content, imageUrl. `PostDto` – DTO для ответа (может подобно структуре JSON).

- Docker-compose override (например, для dev, монтировать volume с кодом, чтобы hot-reload, но это детали).